				   Memo
2
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\domxml\php_domxml.c"
/* {{{ proto bool domxml_elem_set_attribute_node(object attr)
   Sets value of given attribute */
/* since this function is not implemented, outcomment it for the time beeing
PHP_FUNCTION(domxml_elem_set_attribute_node)
{
	zval *id, *arg1, *rv = NULL;
	xmlNode *nodep;
	xmlAttr *attrp, *newattrp;
	int ret;

	if ((ZEND_NUM_ARGS() == 1) && getParameters(ht, 1, &arg1) == SUCCESS) {
		id = getThis();
		nodep = php_dom_get_object(id, le_domxmlelementp, 0 TSRMLS_CC);
		attrp = php_dom_get_object(arg1, le_domxmlattrp, 0 TSRMLS_CC);
	} else {
		WRONG_PARAM_COUNT;
	}

	FIXME: The following line doesn't work 
	newattrp = xmlCopyProp(nodep, attrp);
	if (!newattrp) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "No such attribute '%s'", attrp->name);
		RETURN_FALSE;
	}

	DOMXML_RET_OBJ(rv, (xmlNodePtr) newattrp, &ret);
}
*/
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\domxml\php_domxml.c"
/* {{{ proto int node_namespace([int node])
   Returns list of namespaces */
static int node_namespace(zval **attributes, xmlNode *nodep TSRMLS_DC)
{
	xmlNs *ns;

	/* Get the children of the current node */
	ns = nodep->ns;
	if (!ns) {
		return -1;
	}

	/* create an php array for the children */
	MAKE_STD_ZVAL(*attributes);
	if (array_init(*attributes) == FAILURE) {
		return -1;
	}

	while (ns) {
		zval *pattr;
		int ret;

		pattr = php_domobject_new((xmlNodePtr) ns, &ret, NULL TSRMLS_CC);
		SEPARATE_ZVAL(&pattr);

/*		if(!ret) { */
		if (ns->href)
			add_property_stringl(pattr, "href", (char *) ns->href, strlen(ns->href), 1);
		if (ns->prefix)
			add_property_stringl(pattr, "prefix", (char *) ns->prefix, strlen(ns->prefix), 1);
		add_property_long(pattr, "type", Z_TYPE_P(ns));
/*		} */

		zend_hash_next_index_insert(Z_ARRVAL_PP(attributes), &pattr, sizeof(zval *), NULL);
		ns = ns->next;
	}
	return 0;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\domxml\php_domxml.c"
/* {{{ proto int node_children([int node])
   Returns list of children nodes */
static int node_children(zval **children, xmlNode *nodep TSRMLS_DC)
{
	zval *mchildren, *attributes;
	/* zval *namespace; */
	xmlNode *last;
	int count = 0;

	/* Get the children of the current node */
	last = nodep;
	if (!last) {
		return -1;
	}

	/* create an php array for the children */
	MAKE_STD_ZVAL(*children);
	array_init(*children);

	while (last) {
		zval *child;
		int ret;

		if (NULL != (child = php_domobject_new(last, &ret, NULL TSRMLS_CC))) {
			zend_hash_next_index_insert(Z_ARRVAL_PP(children), &child, sizeof(zval *), NULL);

			/* Get the namespace of the current node and add it as a property */
			/* XXX FIXME XXX */
/*
			if(!node_namespace(&namespace, last))
				zend_hash_update(Z_OBJPROP_P(child), "namespace", sizeof("namespace"), (void *) &namespace, sizeof(zval *), NULL);
*/

			/* Get the attributes of the current node and add it as a property */
			if (node_attributes(&attributes, last TSRMLS_CC) >= 0)
				zend_hash_update(Z_OBJPROP_P(child), "attributes", sizeof("attributes"), (void *) &attributes, sizeof(zval *), NULL);

			/* Get recursively the children of the current node and add it as a property */
			if (node_children(&mchildren, last->children TSRMLS_CC) >= 0)
				zend_hash_update(Z_OBJPROP_P(child), "children", sizeof("children"), (void *) &mchildren, sizeof(zval *), NULL);

			count++;
		}
		last = last->next;
	}
	return count;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gd\gd.c"
/* {{{ proto array gd_info()
 */
PHP_FUNCTION(gd_info)
{
	if (ZEND_NUM_ARGS() != 0) {
		ZEND_WRONG_PARAM_COUNT();
		RETURN_FALSE;
	}

	array_init(return_value);

	add_assoc_string(return_value, "GD Version", PHP_GD_VERSION_STRING, 1);

#ifdef ENABLE_GD_TTF
	add_assoc_bool(return_value, "FreeType Support", 1);
#if HAVE_LIBFREETYPE
	add_assoc_string(return_value, "FreeType Linkage", "with freetype", 1);
#elif HAVE_LIBTTF
	add_assoc_string(return_value, "FreeType Linkage", "with TTF library", 1);
#else
	add_assoc_string(return_value, "FreeType Linkage", "with unknown library", 1);
#endif
#else
	add_assoc_bool(return_value, "FreeType Support", 0);
#endif

#ifdef HAVE_LIBT1
	add_assoc_bool(return_value, "T1Lib Support", 1);
#else
	add_assoc_bool(return_value, "T1Lib Support", 0);
#endif
#ifdef HAVE_GD_GIF_READ
	add_assoc_bool(return_value, "GIF Read Support", 1);
#else
	add_assoc_bool(return_value, "GIF Read Support", 0);
#endif
#ifdef HAVE_GD_GIF_CREATE
	add_assoc_bool(return_value, "GIF Create Support", 1);
#else
	add_assoc_bool(return_value, "GIF Create Support", 0);
#endif
#ifdef HAVE_GD_JPG
	add_assoc_bool(return_value, "JPG Support", 1);
#else
	add_assoc_bool(return_value, "JPG Support", 0);
#endif
#ifdef HAVE_GD_PNG
	add_assoc_bool(return_value, "PNG Support", 1);
#else
	add_assoc_bool(return_value, "PNG Support", 0);
#endif
#ifdef HAVE_GD_WBMP
	add_assoc_bool(return_value, "WBMP Support", 1);
#else
	add_assoc_bool(return_value, "WBMP Support", 0);
#endif
#ifdef HAVE_GD_XBM
	add_assoc_bool(return_value, "XBM Support", 1);
#else
	add_assoc_bool(return_value, "XBM Support", 0);
#endif
#if defined(USE_GD_JISX0208) && defined(HAVE_GD_BUNDLED)
	add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 1);
#else
	add_assoc_bool(return_value, "JIS-mapped Japanese Font Support", 0);
#endif
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gd\gd.c"
/* {{{ proto int imagepscopyfont(int font_index)
   Make a copy of a font for purposes like extending or reenconding */
/* The function in t1lib which this function uses seem to be buggy...
PHP_FUNCTION(imagepscopyfont)
{
	zval **fnt;
	int l_ind, type;
	gd_ps_font *nf_ind, *of_ind;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &fnt) == FAILURE) {
		ZEND_WRONG_PARAM_COUNT();
	}

	convert_to_long_ex(fnt);

	of_ind = zend_list_find(Z_LVAL_PP(fnt), &type);

	if (type != le_ps_font) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "%ld is not a Type 1 font index", Z_LVAL_PP(fnt));
		RETURN_FALSE;
	}

	nf_ind = emalloc(sizeof(gd_ps_font));
	nf_ind->font_id = T1_CopyFont(of_ind->font_id);

	if (nf_ind->font_id < 0) {
		l_ind = nf_ind->font_id;
		efree(nf_ind);
		switch (l_ind) {
			case -1:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "FontID %d is not loaded in memory", l_ind);
				RETURN_FALSE;
				break;
			case -2:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Tried to copy a logical font");
				RETURN_FALSE;
				break;
			case -3:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Memory allocation fault in t1lib");
				RETURN_FALSE;
				break;
			default:
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "An unknown error occurred in t1lib");
				RETURN_FALSE;
				break;
		}
	}

	nf_ind->extend = 1;
	l_ind = zend_list_insert(nf_ind, le_ps_font);
	RETURN_LONG(l_ind);
}
*/
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string textdomain(string domain)
   Set the textdomain to "domain". Returns the current domain */
PHP_NAMED_FUNCTION(zif_textdomain)
{
	zval **domain;
	char *domain_name, *retval;
	char *val;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &domain) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(domain);

	val = Z_STRVAL_PP(domain);
	if (strcmp(val, "") && strcmp(val, "0")) {
		domain_name = val;
	} else {
		domain_name = NULL;
	}

	retval = textdomain(domain_name);

	RETURN_STRING(retval, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string gettext(string msgid)
   Return the translation of msgid for the current domain, or msgid unaltered if a translation does not exist */
PHP_NAMED_FUNCTION(zif_gettext)
{
	zval **msgid;
	char *msgstr;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &msgid) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(msgid);

	msgstr = gettext(Z_STRVAL_PP(msgid));

	RETURN_STRING(msgstr, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string dgettext(string domain_name, string msgid)
   Return the translation of msgid for domain_name, or msgid unaltered if a translation does not exist */
PHP_NAMED_FUNCTION(zif_dgettext)
{
	zval **domain_name, **msgid;
	char *msgstr;

	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &domain_name, &msgid) == FAILURE)	{
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(domain_name);
	convert_to_string_ex(msgid);

	msgstr = dgettext(Z_STRVAL_PP(domain_name), Z_STRVAL_PP(msgid));

	RETURN_STRING(msgstr, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string dcgettext(string domain_name, string msgid, long category)
   Return the translation of msgid for domain_name and category, or msgid unaltered if a translation does not exist */
PHP_NAMED_FUNCTION(zif_dcgettext)
{
	zval **domain_name, **msgid, **category;
	char *msgstr;

	if (ZEND_NUM_ARGS() != 3 || zend_get_parameters_ex(3, &domain_name, &msgid, &category) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(domain_name);
	convert_to_string_ex(msgid);
	convert_to_long_ex(category);

	msgstr = dcgettext(Z_STRVAL_PP(domain_name), Z_STRVAL_PP(msgid), Z_LVAL_PP(category));

	RETURN_STRING(msgstr, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string bindtextdomain(string domain_name, string dir)
   Bind to the text domain domain_name, looking for translations in dir. Returns the current domain */
PHP_NAMED_FUNCTION(zif_bindtextdomain)
{
	zval **domain_name, **dir;
	char *retval, dir_name[MAXPATHLEN];

	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &domain_name, &dir) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(domain_name);
	convert_to_string_ex(dir);

	if (Z_STRVAL_PP(domain_name)[0] == '\0') {
		php_error(E_WARNING, "The first parameter of bindtextdomain must not be empty");
		RETURN_FALSE;
	}
	
	if (Z_STRVAL_PP(dir)[0] != '\0' && strcmp(Z_STRVAL_PP(dir), "0")) {
		VCWD_REALPATH(Z_STRVAL_PP(dir), dir_name);
	} else {
		VCWD_GETCWD(dir_name, MAXPATHLEN);
	}

	retval = bindtextdomain(Z_STRVAL_PP(domain_name), dir_name);

	RETURN_STRING(retval, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string ngettext(string MSGID1, string MSGID2, int N)
   Plural version of gettext() */
PHP_NAMED_FUNCTION(zif_ngettext)
{
	zval **msgid1, **msgid2, **count;
	char *msgstr;

	RETVAL_FALSE;

	if (ZEND_NUM_ARGS() != 3 || zend_get_parameters_ex(3, &msgid1, &msgid2, &count) == FAILURE) {
		WRONG_PARAM_COUNT;
	} else {
		convert_to_string_ex(msgid1);
		convert_to_string_ex(msgid2);
		convert_to_long_ex(count);

		msgstr = ngettext(Z_STRVAL_PP(msgid1), Z_STRVAL_PP(msgid2), Z_LVAL_PP(count));
		if (msgstr) {
			RETVAL_STRING (msgstr, 1);
		}
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string dngettext (string domain, string msgid1, string msgid2, int count)
   Plural version of dgettext() */
PHP_NAMED_FUNCTION(zif_dngettext)
{
	zval **domain, **msgid1, **msgid2, **count;

	RETVAL_FALSE;

	if (ZEND_NUM_ARGS() != 4 || zend_get_parameters_ex(4, &domain, &msgid1, &msgid2, &count) == FAILURE) {
		WRONG_PARAM_COUNT;
	} else {
		char *msgstr;
		
		convert_to_string_ex(domain);
		convert_to_string_ex(msgid1);
		convert_to_string_ex(msgid2);
		convert_to_long_ex(count);

		msgstr = dngettext(Z_STRVAL_PP(domain), Z_STRVAL_PP(msgid1), Z_STRVAL_PP(msgid2), Z_LVAL_PP(count));
		if (msgstr) {
			RETVAL_STRING(msgstr, 1);
		}
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string dcngettext (string domain, string msgid1, string msgid2, int n, int category)
   Plural version of dcgettext() */								
PHP_NAMED_FUNCTION(zif_dcngettext)
{
	zval **domain, **msgid1, **msgid2, **count, **category;

	RETVAL_FALSE;

	if (ZEND_NUM_ARGS() != 5 || zend_get_parameters_ex(4, &domain, &msgid1, &msgid2, &count, &category) == FAILURE) {
		WRONG_PARAM_COUNT;
	} else {
		char* msgstr = NULL;

		convert_to_string_ex(domain);
		convert_to_string_ex(msgid1);
		convert_to_string_ex(msgid2);
		convert_to_long_ex(count);
		convert_to_long_ex(category);

		msgstr = dcngettext(Z_STRVAL_PP(domain), Z_STRVAL_PP(msgid1), Z_STRVAL_PP(msgid2), Z_LVAL_PP(count), Z_LVAL_PP(category));

		if (msgstr) {
			RETVAL_STRING(msgstr, 1);
		}
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\gettext\gettext.c"
/* {{{ proto string bind_textdomain_codeset (string domain, string codeset)
   Specify the character encoding in which the messages from the DOMAIN message catalog will be returned. */
PHP_NAMED_FUNCTION(zif_bind_textdomain_codeset)
{
	zval **domain, **codeset;
	char *retval;
	
	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &domain, &codeset) == FAILURE) {
		WRONG_PARAM_COUNT;
	} else {
		convert_to_string_ex(domain);
		convert_to_string_ex(codeset);
		
		retval = bind_textdomain_codeset(Z_STRVAL_PP(domain), Z_STRVAL_PP(codeset));

		if (!retval) {
			RETURN_FALSE;
		}
		RETURN_STRING(retval, 1);
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\hyperwave\hw.c"
/* {{{ proto void hw_outputdocument(hwdoc doc)
   An alias for hw_output_document */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\hyperwave\hw.c"
/* {{{ proto string hw_documentbodytag(hwdoc doc [, string prefix])
   An alias for hw_document_bodytag */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\hyperwave\hw.c"
/* {{{ proto int hw_documentsize(hwdoc doc)
   An alias for hw_document_size */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\hyperwave\hw.c"
/* {{{ proto string hw_documentattributes(hwdoc doc)
   An alias for hw_document_attributes */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\iconv\iconv.c"
/* {{{ proto string iconv(string in_charset, string out_charset, string str)
   Returns str converted to the out_charset character set */
PHP_NAMED_FUNCTION(php_if_iconv)
{
	char *in_charset, *out_charset, *in_buffer, *out_buffer;
	size_t out_len;
	int in_charset_len, out_charset_len, in_buffer_len;
	php_iconv_err_t err;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss",
		&in_charset, &in_charset_len, &out_charset, &out_charset_len, &in_buffer, &in_buffer_len) == FAILURE)
		return;

	err = php_iconv_string(in_buffer, (size_t)in_buffer_len,
		&out_buffer, &out_len, in_charset, out_charset);
	_php_iconv_show_error(err, in_charset, out_charset TSRMLS_CC); 
	if (out_buffer != NULL) {
		RETVAL_STRINGL(out_buffer, out_len, 0);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ming\ming.c"
/* {{{ proto void swfmovie_nextframe(void)  
*/
PHP_FUNCTION(swfmovie_nextFrame)
{
	SWFMovie_nextFrame(getMovie(getThis() TSRMLS_CC));
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ming\ming.c"
/* {{{ proto object swfmovie_add(object SWFBlock) 
*/
PHP_FUNCTION(swfmovie_add)
{
	zval **zchar;
	int ret;
	SWFBlock block;
	SWFDisplayItem item;
	SWFMovie movie = getMovie(getThis() TSRMLS_CC);

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &zchar) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	
	convert_to_object_ex(zchar);

	/* XXX - SWFMovie_add deals w/ all block types.  Probably will need to add that.. */
	if (Z_OBJCE_PP(zchar) == &action_class_entry) {
		block = (SWFBlock) getAction(*zchar TSRMLS_CC);
	} else {
		block = (SWFBlock) getCharacter(*zchar TSRMLS_CC);
	}

	item = SWFMovie_add(movie, block);

	if (item != NULL) {
		/* try and create a displayitem object */
		ret = zend_list_insert(item, le_swfdisplayitemp);
		object_init_ex(return_value, &displayitem_class_entry);
		add_property_resource(return_value, "displayitem", ret);
	}
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ming\ming.c"
/* {{{ proto void swfmovie_labelframe(object SWFBlock)
*/
PHP_FUNCTION(swfmovie_remove)
{
	zval **zchar;
	SWFDisplayItem item;
	SWFMovie movie = getMovie(getThis() TSRMLS_CC);

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &zchar) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_object_ex(zchar);
	item = getDisplayItem(*zchar TSRMLS_CC);
	SWFMovie_remove(movie, item);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ming\ming.c"
/* {{{ proto int swfmovie_output([int compression])
*/
static void phpByteOutputMethod(byte b, void *data)
{
	TSRMLS_FETCH();

	php_write(&b, 1 TSRMLS_CC);
}

PHP_FUNCTION(swfmovie_output)
{
	SWFMovie movie = getMovie(getThis() TSRMLS_CC);
#ifdef HAVE_MING_ZLIB
	zval **zlimit = NULL;
	int limit = -1;
	int argc = ZEND_NUM_ARGS();

	if(argc==0) {
		limit = 6;
	} else {
		if (zend_get_parameters_ex(1, &zlimit) == FAILURE) {
			WRONG_PARAM_COUNT;
		}

		convert_to_long_ex(zlimit);
		limit = Z_LVAL_PP(zlimit);

		if ((limit < 0) || (limit > 9)) {
			php_error(E_WARNING,"compression level must be within 0..9");
			RETURN_FALSE;
		}
	}
#endif

#ifdef HAVE_NEW_MING
	RETURN_LONG(SWFMovie_output(movie, &phpByteOutputMethod, NULL, limit));
#else
	RETURN_LONG(SWFMovie_output(movie, &phpByteOutputMethod, NULL));
#endif
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ming\ming.c"
/* {{{ proto int swfmovie_saveToFile(stream x [, int compression])
*/
static void phpStreamOutputMethod(byte b, void * data)
{
	TSRMLS_FETCH();

	php_stream_write((php_stream*)data, &b, 1);
}

PHP_FUNCTION(swfmovie_saveToFile)
{
	zval **x;
#ifdef HAVE_MING_ZLIB
	zval **zlimit = NULL;
	int limit = -1;
#endif
	SWFMovie movie = getMovie(getThis() TSRMLS_CC);
	php_stream *what;

	switch (ZEND_NUM_ARGS()) {
	case 1:
		if (zend_get_parameters_ex(1, &x) == FAILURE)
			WRONG_PARAM_COUNT;
		break;
	case 2:
#ifdef HAVE_MING_ZLIB
		if (zend_get_parameters_ex(2, &x, &zlimit) == FAILURE)
			WRONG_PARAM_COUNT;
		convert_to_long_ex(zlimit);
		limit = Z_LVAL_PP(zlimit);
		if ((limit < 0) || (limit > 9)) {
			php_error(E_WARNING,"compression level must be within 0..9");
			RETURN_FALSE;
		}
#endif
		break;
	default:
		WRONG_PARAM_COUNT;
	}

	ZEND_FETCH_RESOURCE(what, php_stream *, x, -1,"File-Handle",php_file_le_stream());
#ifdef HAVE_NEW_MING
	RETURN_LONG(SWFMovie_output(movie, &phpStreamOutputMethod, what, limit));
#else
	RETURN_LONG(SWFMovie_output(movie, &phpStreamOutputMethod, what));
#endif
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_alloc_agent(string dbaddr [, string dbmode])
   Allocate mnoGoSearch session */
DLEXPORT PHP_FUNCTION(udm_alloc_agent)
{
	switch(ZEND_NUM_ARGS()){

		case 1: {
				pval **yydbaddr;
				char *dbaddr;
				UDM_ENV   * Env;
				UDM_AGENT * Agent;
				
				if(zend_get_parameters_ex(1,&yydbaddr)==FAILURE){
					RETURN_FALSE;
				}
				convert_to_string_ex(yydbaddr);
				dbaddr = Z_STRVAL_PP(yydbaddr);
			
#if UDM_VERSION_ID >= 30204
				Env=UdmEnvInit(NULL);
				UdmVarListReplaceStr(&Env->Vars,"SyslogFacility","local7");
#if UDM_VERSION_ID >= 30215
				UdmSetLogLevel(NULL,0);
#else
				UdmSetLogLevel(Env,0);
#endif
				UdmOpenLog("mnoGoSearch-php",Env,0);
#if UDM_VERSION_ID <= 30210
				if(!memcmp(dbaddr,"searchd:",8)){
					UDM_URL	Url;
					UdmURLParse(&Url,dbaddr);
					UdmDBListAdd(&Env->sdcl,Url.hostinfo);
				}
				
				UdmVarListReplaceStr(&Env->Vars,"DBAddr",dbaddr);
				
				if(UDM_OK!=UdmDBSetAddr(Env->db,dbaddr,UDM_OPEN_MODE_READ)){
				    sprintf(Env->errstr,"Invalid DBAddr: '%s'",dbaddr);
#if UDM_VERSION_ID <= 30207
				    Env->errcode=1;
#endif
				    php_error_docref(NULL TSRMLS_CC, E_WARNING,"Invalid DBAddr");
				    RETURN_FALSE;
				}
#else
				UdmDBListAdd(&Env->dbl,dbaddr, UDM_OPEN_MODE_WRITE);
#endif
				Agent=UdmAgentInit(NULL,Env,0);
#elif UDM_VERSION_ID >= 30200
				Env=UdmAllocEnv();
				Env->vars=UdmAllocVarList();
				Env->DBAddr=strdup(dbaddr);
				UdmEnvSetDBMode(Env,"single");
				Agent=UdmAllocAgent(Env,0,UDM_OPEN_MODE_READ);
#else				
				Env=UdmAllocEnv();
				UdmEnvSetDBAddr(Env,dbaddr);
				Agent=UdmAllocAgent(Env,0,UDM_OPEN_MODE_READ);
#endif							
				ZEND_REGISTER_RESOURCE(return_value,Agent,le_link);
			}
			break;
			
		case 2: {
				pval **yydbaddr;
				pval **yydbmode;
				char *dbaddr;
				char *dbmode;
				UDM_ENV   * Env;
				UDM_AGENT * Agent;
				
				if(zend_get_parameters_ex(2,&yydbaddr,&yydbmode)==FAILURE){
					RETURN_FALSE;
				}
				convert_to_string_ex(yydbaddr);
				convert_to_string_ex(yydbmode);
				dbaddr = Z_STRVAL_PP(yydbaddr);
				dbmode = Z_STRVAL_PP(yydbmode);
				
#if UDM_VERSION_ID >= 30204
				Env=UdmEnvInit(NULL);
				UdmVarListReplaceStr(&Env->Vars,"SyslogFacility","local7");
#if UDM_VERSION_ID >= 30215
				UdmSetLogLevel(NULL,0);
#else
				UdmSetLogLevel(Env,0);
#endif
				UdmOpenLog("mnoGoSearch-php",Env,0);
#if UDM_VERSION_ID <= 30210
				if(!memcmp(dbaddr,"searchd:",8)){
					UDM_URL	Url;
					UdmURLParse(&Url,dbaddr);
					UdmDBListAdd(&Env->sdcl,Url.hostinfo);
				}
				UdmVarListReplaceStr(&Env->Vars,"DBAddr",dbaddr);
				if(UDM_OK!=UdmDBSetAddr(Env->db,dbaddr,UDM_OPEN_MODE_READ)){
				    sprintf(Env->errstr,"Invalid DBAddr: '%s'",dbaddr);
#if UDM_VERSION_ID <= 30207
				    Env->errcode=1;
#endif
				    php_error_docref(NULL TSRMLS_CC, E_WARNING,"Invalid DBAddr");
				    RETURN_FALSE;
				}
#else
				UdmDBListAdd(&Env->dbl,dbaddr, UDM_OPEN_MODE_WRITE);
#endif
				Agent=UdmAgentInit(NULL,Env,0);
#elif UDM_VERSION_ID >= 30200
				Env=UdmAllocEnv();
				Env->vars=UdmAllocVarList();
				Env->DBAddr=strdup(dbaddr);
				UdmEnvSetDBMode(Env,dbmode);
				Agent=UdmAllocAgent(Env,0,UDM_OPEN_MODE_READ);
#else
				Env=UdmAllocEnv();				
				UdmEnvSetDBAddr(Env,dbaddr);
				UdmEnvSetDBMode(Env,dbmode);
				Agent=UdmAllocAgent(Env,0,UDM_OPEN_MODE_READ);
#endif
				ZEND_REGISTER_RESOURCE(return_value,Agent,le_link);
			}
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_set_agent_param(int agent, int var, string val)
   Set mnoGoSearch agent session parameters */
DLEXPORT PHP_FUNCTION(udm_set_agent_param)
{
	pval **yyagent, **yyvar, **yyval;
	char *val;
	int var;
	UDM_AGENT * Agent;

	switch(ZEND_NUM_ARGS()){
	
		case 3: 		
			if(zend_get_parameters_ex(3,&yyagent,&yyvar,&yyval)==FAILURE){
				RETURN_FALSE;
			}
			convert_to_long_ex(yyvar);
			convert_to_string_ex(yyval);
			ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-agent", le_link);
			var = Z_LVAL_PP(yyvar);
			val = Z_STRVAL_PP(yyval);
			
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	
	switch(var){
		case UDM_PARAM_PAGE_SIZE: 
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"ps",val);
#else
			Agent->page_size=atoi(val);
			if(Agent->page_size<1)Agent->page_size=20;
#endif
			break;
			
		case UDM_PARAM_PAGE_NUM: 
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"np",val);
#else
			Agent->page_number=atoi(val);
			if(Agent->page_number<0)Agent->page_number=0;
#endif
			break;

		case UDM_PARAM_SEARCH_MODE:
			switch (atoi(val)){
					case UDM_MODE_ALL:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"m","all");
#else
						Agent->search_mode=UDM_MODE_ALL;
#endif
						break;
						
					case UDM_MODE_ANY:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"m","any");
#else
						Agent->search_mode=UDM_MODE_ANY;
#endif
						break;
						
					case UDM_MODE_BOOL: 
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"m","bool");
#else
						Agent->search_mode=UDM_MODE_BOOL;
#endif
						break;

					case UDM_MODE_PHRASE: 
#if UDM_VERSION_ID >= 30200
    						php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown search mode");
						RETURN_FALSE;
#else
						Agent->search_mode=UDM_MODE_PHRASE;
#endif
						break;
						
					default:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"m","all");
#else
						Agent->search_mode=UDM_MODE_ALL;
#endif						
						php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown search mode");
						RETURN_FALSE;
						break;
			}
			break;

		case UDM_PARAM_WORD_MATCH:
			switch (atoi(val)){
					case UDM_MATCH_WORD:					
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"wm","wrd");
#else
						Agent->word_match=UDM_MATCH_WORD;
#endif
						break;

					case UDM_MATCH_BEGIN:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"wm","beg");
#else
						Agent->word_match=UDM_MATCH_BEGIN;
#endif
						break;

					case UDM_MATCH_END:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"wm","end");
#else
						Agent->word_match=UDM_MATCH_END;
#endif
						break;

					case UDM_MATCH_SUBSTR:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"wm","sub");
#else
						Agent->word_match=UDM_MATCH_SUBSTR;
#endif
						break;
						
					default:
#if UDM_VERSION_ID >= 30204
						UdmVarListReplaceStr(&Agent->Conf->Vars,"wm","wrd");
#else
						Agent->word_match=UDM_MATCH_WORD;
#endif						
						php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown word match mode");
						RETURN_FALSE;
						break;
			}
			break;
		case UDM_PARAM_CACHE_MODE: 
			switch (atoi(val)){
				case UDM_ENABLED:
#if UDM_VERSION_ID < 30200
					Agent->cache_mode=UDM_ENABLED;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"Cache","yes");
#else		
					UdmReplaceStrVar(Agent->Conf->vars,"Cache","yes",UDM_VARSRC_GLOBAL);
#endif
					break;
					
				case UDM_DISABLED:
#if UDM_VERSION_ID < 30200								
					Agent->cache_mode=UDM_DISABLED;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"Cache","no");
#else										
					UdmReplaceStrVar(Agent->Conf->vars,"Cache","no",UDM_VARSRC_GLOBAL);
#endif
					break;
					
				default:
#if UDM_VERSION_ID < 30200												
					Agent->cache_mode=UDM_DISABLED;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"Cache","no");
#else									
					UdmReplaceStrVar(Agent->Conf->vars,"Cache","no",UDM_VARSRC_GLOBAL);
#endif						
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown cache mode");
					RETURN_FALSE;
					break;
			}
			
			break;
			
		case UDM_PARAM_TRACK_MODE: 
			switch (atoi(val)){
				case UDM_ENABLED:
#if UDM_VERSION_ID < 30200												
					Agent->track_mode|=UDM_TRACK_QUERIES;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"TrackQuery","yes");
#else
					UdmReplaceStrVar(Agent->Conf->vars,"TrackQuery","yes",UDM_VARSRC_GLOBAL);
#endif
					break;
					
				case UDM_DISABLED:
#if UDM_VERSION_ID < 30200						
					Agent->track_mode &= ~(UDM_TRACK_QUERIES);    
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"TrackQuery","no");
#else
					UdmReplaceStrVar(Agent->Conf->vars,"TrackQuery","no",UDM_VARSRC_GLOBAL);
#endif
					
					break;
					
				default:
#if UDM_VERSION_ID < 30200						
					Agent->track_mode &= ~(UDM_TRACK_QUERIES);    
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"TrackQuery","no");
#else
					UdmReplaceStrVar(Agent->Conf->vars,"TrackQuery","no",UDM_VARSRC_GLOBAL);
#endif				
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown track mode");
					RETURN_FALSE;
					break;
			}
			
			break;
		
		case UDM_PARAM_PHRASE_MODE: 
#if UDM_VERSION_ID < 30200								
			switch (atoi(val)){
				case UDM_ENABLED:
					Agent->Conf->use_phrases=UDM_ENABLED;
					break;
					
				case UDM_DISABLED:
					Agent->Conf->use_phrases=UDM_DISABLED;
					break;
					
				default:
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown phrase mode");
					RETURN_FALSE;
					break;
			}
#endif			
			break;

		case UDM_PARAM_ISPELL_PREFIXES: 
			switch (atoi(val)){
				case UDM_ENABLED:
#if UDM_VERSION_ID < 30200								
					Agent->Conf->ispell_mode |= UDM_ISPELL_USE_PREFIXES;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"IspellUsePrefixes","1");
#else
					UdmAddIntVar(Agent->Conf->vars, "IspellUsePrefixes", 1, UDM_VARSRC_GLOBAL);
#endif								
					break;
					
				case UDM_DISABLED:
#if UDM_VERSION_ID < 30200												
					Agent->Conf->ispell_mode &= ~UDM_ISPELL_USE_PREFIXES;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"IspellUsePrefixes","0");
#else
					UdmAddIntVar(Agent->Conf->vars, "IspellUsePrefixes", 0, UDM_VARSRC_GLOBAL);
#endif																	
					break;

				
				default:
#if UDM_VERSION_ID < 30200								
					Agent->Conf->ispell_mode |= UDM_ISPELL_USE_PREFIXES;
#elif UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"IspellUsePrefixes","0");
#else
					UdmAddIntVar(Agent->Conf->vars, "IspellUsePrefixes", 1, UDM_VARSRC_GLOBAL);					
#endif												
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown ispell prefixes mode");
					RETURN_FALSE;
					break;
			}

			break;

		case UDM_PARAM_CHARSET:
		case UDM_PARAM_LOCAL_CHARSET:
#if UDM_VERSION_ID < 30200						
			Agent->Conf->local_charset=UdmGetCharset(val);
			Agent->charset=Agent->Conf->local_charset;
#elif UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"LocalCharset",val);
			{
			    const char * charset=UdmVarListFindStr(&Agent->Conf->Vars,"LocalCharset","iso-8859-1");
			    Agent->Conf->lcs=UdmGetCharSet(charset);
			}
#else
			Agent->Conf->local_charset=strdup(val);
			UdmReplaceStrVar(Agent->Conf->vars,"LocalCharset",val,UDM_VARSRC_GLOBAL);
#endif

			break;
			
#if UDM_VERSION_ID >= 30200
		case UDM_PARAM_BROWSER_CHARSET:
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"BrowserCharset",val);
			{
			    const char * charset=UdmVarListFindStr(&Agent->Conf->Vars,"BrowserCharset","iso-8859-1");
			    Agent->Conf->bcs=UdmGetCharSet(charset);
			}
#else
			Agent->Conf->browser_charset=strdup(val);
			UdmReplaceStrVar(Agent->Conf->vars,"BrowserCharset",val,UDM_VARSRC_GLOBAL);
#endif			
			break;

		case UDM_PARAM_HLBEG:
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"HlBeg",val);
#else
			UdmReplaceStrVar(Agent->Conf->vars,"HlBeg",val,UDM_VARSRC_GLOBAL);
#endif			
			break;

		case UDM_PARAM_HLEND:
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"HlEnd",val);
#else
			UdmReplaceStrVar(Agent->Conf->vars,"HlEnd",val,UDM_VARSRC_GLOBAL);
#endif			
			break;
			
		case UDM_PARAM_SYNONYM:
			if (UdmSynonymListLoad(Agent->Conf,val)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s",Agent->Conf->errstr);
				RETURN_FALSE;
#if UDM_VERSION_ID >= 30204
			} else UdmSynonymListSort(&(Agent->Conf->Synonyms));
#else
			} else UdmSynonymListSort(&(Agent->Conf->SynList));
#endif			
			break;
			
		case UDM_PARAM_SEARCHD:
#if UDM_VERSION_ID <= 30203
			UdmSDCLientListAdd(&(Agent->Conf->sdcl),val);
			{
				size_t i;
				for(i=0;i<Agent->Conf->sdcl.nclients;i++){
					UdmSDCLientListAdd(&Agent->sdcl,Agent->Conf->sdcl.Clients[i].addr);
				}
			}
#endif			
			break;

		case UDM_PARAM_QSTRING:
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"QUERY_STRING",val);
#else
			UdmReplaceStrVar(Agent->Conf->vars,"QUERY_STRING",val,UDM_VARSRC_GLOBAL);
#endif			
			break;


		case UDM_PARAM_REMOTE_ADDR:
#if UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"IP",val);
#else
			UdmReplaceStrVar(Agent->Conf->vars,"IP",val,UDM_VARSRC_GLOBAL);
#endif			
			break;			
#endif
			
		case UDM_PARAM_STOPTABLE:
#if UDM_VERSION_ID < 30200								
			strcat(Agent->Conf->stop_tables," ");
			strcat(Agent->Conf->stop_tables,val);
#endif
			break;

		case UDM_PARAM_STOPFILE: 
#if UDM_VERSION_ID >= 30204
			if (UdmStopListLoad(Agent->Conf,val)) {
#else
			if (UdmFileLoadStopList(Agent->Conf,val)) {
#endif
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", Agent->Conf->errstr);
				RETURN_FALSE;
			}
			break;
			
		case UDM_PARAM_WEIGHT_FACTOR: 
#if UDM_VERSION_ID < 30200										
			Agent->weight_factor=strdup(val);
#elif UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"wf",val);
#else
			UdmReplaceStrVar(Agent->Conf->vars,"wf",val,UDM_VARSRC_GLOBAL);
			{
				size_t len;
	
		                len=strlen(val);
				if((len>0)&&(len<256)){
				    const char *sec;
				    int sn;
				
				    for(sn=0;sn<256;sn++){
					    Agent->wf[sn]=0;
				    }
				
				    for(sec=val+len-1;sec>=val;sec--){
					    Agent->wf[len-(sec-val)]=UdmHex2Int(*sec);
	                	    }
        			}                                                          			
			}
#endif			    
			break;
			
		case UDM_PARAM_MIN_WORD_LEN: 
#if UDM_VERSION_ID >= 30204
			Agent->Conf->WordParam.min_word_len=atoi(val);
#else
			Agent->Conf->min_word_len=atoi(val);
#endif			    
			break;
			
		case UDM_PARAM_MAX_WORD_LEN: 
#if UDM_VERSION_ID >= 30204
			Agent->Conf->WordParam.max_word_len=atoi(val);
#else
			Agent->Conf->max_word_len=atoi(val);
#endif			    
			break;
			
		case UDM_PARAM_CROSS_WORDS: 
			switch (atoi(val)){
				case UDM_ENABLED:
#if UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"CrossWords","yes");
#else
					Agent->Conf->use_crossword=UDM_ENABLED;
#endif
					break;
					
				case UDM_DISABLED:
#if UDM_VERSION_ID >= 30204
					UdmVarListReplaceStr(&Agent->Conf->Vars,"CrossWords","no");
#else
					Agent->Conf->use_crossword=UDM_DISABLED;
#endif
					break;
					
				default:
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown crosswords mode");
					RETURN_FALSE;
					break;
			}
			
			break;

#if UDM_VERSION_ID > 30112

		case UDM_PARAM_VARDIR:
#if UDM_VERSION_ID < 30200
			udm_snprintf(Agent->Conf->vardir,sizeof(Agent->Conf->vardir)-1,"%s%s",val,UDMSLASHSTR);
#elif UDM_VERSION_ID >= 30208
			UdmVarListReplaceStr(&Agent->Conf->Vars,"Vardir",val);
#elif UDM_VERSION_ID >= 30204
			UdmVarListReplaceStr(&Agent->Conf->Vars,"Vardir",val);
			snprintf(Agent->Conf->vardir,sizeof(Agent->Conf->vardir)-1,"%s%s",val,UDMSLASHSTR);
#else			
			snprintf(Agent->Conf->vardir,sizeof(Agent->Conf->vardir)-1,"%s%s",val,UDMSLASHSTR);
#endif			
			break;
#endif			

#if UDM_VERSION_ID >= 30204
		case UDM_PARAM_QUERY:
			UdmVarListReplaceStr(&Agent->Conf->Vars,"q",val);

			break;

		case UDM_PARAM_STORED:
			UdmVarListReplaceStr(&Agent->Conf->Vars,"StoredAddr",val);

			break;
#endif
			
#if UDM_VERSION_ID >= 30207
		case UDM_PARAM_GROUPBYSITE: 
			switch (atoi(val)){
				case UDM_ENABLED:
					UdmVarListReplaceStr(&Agent->Conf->Vars,"GroupBySite","yes");
					
					break;
					
				case UDM_DISABLED:
					UdmVarListReplaceStr(&Agent->Conf->Vars,"GroupBySite","no");

					break;
					
				default:
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown groupbysite mode");
					RETURN_FALSE;
					break;
			}
			
			break;
			
		case UDM_PARAM_SITEID: 
			UdmVarListReplaceStr(&Agent->Conf->Vars,"site",val);
		
			break;

		case UDM_PARAM_DETECT_CLONES: 
			switch (atoi(val)){
				case UDM_ENABLED:
					UdmVarListReplaceStr(&Agent->Conf->Vars,"DetectClones","yes");
					
					break;
					
				case UDM_DISABLED:
					UdmVarListReplaceStr(&Agent->Conf->Vars,"DetectClones","no");

					break;
					
				default:
					php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown clones mode");
					RETURN_FALSE;
					break;
			}
			
			break;
#endif

#if UDM_VERSION_ID >= 30214
		case UDM_PARAM_SORT_ORDER: 
			UdmVarListReplaceStr(&Agent->Conf->Vars,"s",val);
		
			break;
#endif

#if UDM_VERSION_ID >= 30215
		case UDM_PARAM_RESULTS_LIMIT: 
			UdmVarListReplaceStr(&Agent->Conf->Vars,"ResultsLimit",val);
		
			break;
#endif

#if UDM_VERSION_ID >= 30216
		case UDM_PARAM_EXCERPT_SIZE: 
			UdmVarListReplaceStr(&Agent->Conf->Vars,"ExcerptSize",val);
		
			break;
		case UDM_PARAM_EXCERPT_PADDING: 
			UdmVarListReplaceStr(&Agent->Conf->Vars,"ExcerptPadding",val);
		
			break;
#endif
		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown agent session parameter");
			RETURN_FALSE;
			break;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_load_ispell_data(int agent, int var, string val1, [string charset], string val2, int flag)
   Load ispell data */
DLEXPORT PHP_FUNCTION(udm_load_ispell_data)
{
	pval **yyagent, **yyvar, **yyval1, **yyval2, **yyflag, **yycharset ;
	char *val1, *val2, *charset;
	int var, flag;
	UDM_AGENT * Agent;

	switch(ZEND_NUM_ARGS()){
	
		case 5: 		
			if(zend_get_parameters_ex(5,&yyagent,&yyvar,&yyval1,&yyval2,&yyflag)==FAILURE){
				RETURN_FALSE;
			}
			convert_to_long_ex(yyvar);
			convert_to_long_ex(yyflag);
			convert_to_string_ex(yyval1);
			convert_to_string_ex(yyval2);
			ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-agent", le_link);
			var  = Z_LVAL_PP(yyvar);
			flag = Z_LVAL_PP(yyflag);
			val1 = Z_STRVAL_PP(yyval1);
			val2 = Z_STRVAL_PP(yyval2);
			charset = "us-ascii";
			
			break;

		case 6: 		
			if(zend_get_parameters_ex(6,&yyagent,&yyvar,&yyval1,&yycharset,&yyval2,&yyflag)==FAILURE){
				RETURN_FALSE;
			}
			convert_to_long_ex(yyvar);
			convert_to_long_ex(yyflag);
			convert_to_string_ex(yyval1);
			convert_to_string_ex(yyval2);
			convert_to_string_ex(yycharset);
			ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-agent", le_link);
			var  = Z_LVAL_PP(yyvar);
			flag = Z_LVAL_PP(yyflag);
			val1 = Z_STRVAL_PP(yyval1);
			val2 = Z_STRVAL_PP(yyval2);
			charset = Z_STRVAL_PP(yycharset);
			
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}


	switch(var){
#if UDM_VERSION_ID < 30200		
		case UDM_ISPELL_TYPE_DB: 
			Agent->Conf->ispell_mode |= UDM_ISPELL_MODE_DB;
			
			if (UdmDBImportAffixes(Agent,Agent->charset) || 
			    UdmImportDictionaryFromDB(Agent)) {
				RETURN_FALSE;
			} 
									
			break;
			
#if UDM_VERSION_ID > 30111

		case UDM_ISPELL_TYPE_SERVER:
			Agent->Conf->ispell_mode &= ~UDM_ISPELL_MODE_DB;
			Agent->Conf->ispell_mode |=  UDM_ISPELL_MODE_SERVER;
			
			Agent->Conf->spellhost = strdup(val1);
		
			break;
			
#endif			
#endif

		case UDM_ISPELL_TYPE_AFFIX: 
#if UDM_VERSION_ID < 30200		
			Agent->Conf->ispell_mode &= ~UDM_ISPELL_MODE_DB;

#if UDM_VERSION_ID > 30111
			Agent->Conf->ispell_mode &= ~UDM_ISPELL_MODE_SERVER;
#endif
			
			if (UdmImportAffixes(Agent->Conf,val1,val2,NULL,0)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot load affix file %s",val2);
				RETURN_FALSE;
			}
#else
			if (UdmImportAffixes(Agent->Conf,val1,charset,val2)) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot load affix file %s",val2);
				RETURN_FALSE;
			}
    
#endif
			break;
			
		case UDM_ISPELL_TYPE_SPELL: 
#if UDM_VERSION_ID < 30200				
			Agent->Conf->ispell_mode &= ~UDM_ISPELL_MODE_DB;
			
#if UDM_VERSION_ID > 30111
			Agent->Conf->ispell_mode &= ~UDM_ISPELL_MODE_SERVER;
#endif
			
			if (UdmImportDictionary(Agent->Conf,val1,val2,1,"")) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot load spell file %s",val2);
				RETURN_FALSE;
			}
#else
			if (UdmImportDictionary(Agent->Conf,val1,charset,val2,0,"")) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Cannot load spell file %s",val2);
				RETURN_FALSE;
			}
#endif
			break;


		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown ispell type parameter");
			RETURN_FALSE;
			break;
	}
	
	if (flag) {
#if UDM_VERSION_ID >= 30204
		if(Agent->Conf->Spells.nspell) {
			UdmSortDictionary(&Agent->Conf->Spells);
		  	UdmSortAffixes(&Agent->Conf->Affixes,&Agent->Conf->Spells);
		}
#else
		if(Agent->Conf->nspell) {
			UdmSortDictionary(Agent->Conf);
		  	UdmSortAffixes(Agent->Conf);
		}
#endif
	}
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_free_ispell_data(int agent)
   Free memory allocated for ispell data */
DLEXPORT PHP_FUNCTION(udm_free_ispell_data)
{
	pval ** yyagent;
	UDM_AGENT * Agent;
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-Agent", le_link);

#if UDM_VERSION_ID >= 30204
	UdmSpellListFree(&Agent->Conf->Spells);
	UdmAffixListFree(&Agent->Conf->Affixes);
#elif UDM_VERSION_ID > 30111
	UdmFreeIspell(Agent->Conf);
#endif
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_add_search_limit(int agent, int var, string val)
   Add mnoGoSearch search restrictions */
DLEXPORT PHP_FUNCTION(udm_add_search_limit)
{
	pval **yyagent, **yyvar, **yyval;
	char *val;
	int var;
	UDM_AGENT * Agent;

	switch(ZEND_NUM_ARGS()){
	
		case 3: 		
			if(zend_get_parameters_ex(3,&yyagent,&yyvar,&yyval)==FAILURE){
				RETURN_FALSE;
			}
			convert_to_long_ex(yyvar);
			convert_to_string_ex(yyval);
			ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-agent", le_link);
			var = Z_LVAL_PP(yyvar);
			val = Z_STRVAL_PP(yyval);
			
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	
	switch(var){
		case UDM_LIMIT_URL: 
#if UDM_VERSION_ID >= 30204			
			UdmVarListAddStr(&Agent->Conf->Vars,"ul",val);
#else
			UdmAddURLLimit(Agent->Conf,val);
#endif		
			break;
			
		case UDM_LIMIT_TAG: 
#if UDM_VERSION_ID >= 30204			
			UdmVarListAddStr(&Agent->Conf->Vars,"t",val);
#else
			UdmAddTagLimit(Agent->Conf,val);
#endif		
			break;

		case UDM_LIMIT_LANG: 
#if UDM_VERSION_ID >= 30204			
			UdmVarListAddStr(&Agent->Conf->Vars,"lang",val);
#else
			UdmAddLangLimit(Agent->Conf,val);
#endif			
			break;

		case UDM_LIMIT_CAT: 
#if UDM_VERSION_ID >= 30204
			UdmVarListAddStr(&Agent->Conf->Vars,"cat",val);
#else
			UdmAddCatLimit(Agent->Conf,val);
#endif			
			break;

		case UDM_LIMIT_TYPE: 
#if UDM_VERSION_ID >= 30207
			UdmVarListAddStr(&Agent->Conf->Vars,"type",val);
#endif			
			break;
			
		case UDM_LIMIT_DATE: 
#if UDM_VERSION_ID < 30200			
			{
			struct udm_stl_info_t stl_info = { 0, 0, 0 };
			char *edate;
			
			if (val[0] == '>') {
				Z_TYPE(stl_info)=1;
			} else if (val[0] == '<') {
				Z_TYPE(stl_info)=-1;
			} else if((val[0]=='#')&&(edate=strchr(val,','))){
				Z_TYPE(stl_info)=2;
				stl_info.t2=(time_t)(atol(edate+1));
			} else {
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Incorrect date limit format");
				RETURN_FALSE;
			}			
			
			stl_info.t1=(time_t)(atol(val+1));
			UdmAddTimeLimit(Agent->Conf,&stl_info);
			}
#elif UDM_VERSION_ID >= 30210
                        {
                    	    struct tm       *d_tm;
                            time_t          d_t;
                            char            *d_val2;
                            char            d_db[20], d_de[20];
                            d_t = atol (val+1);
                            d_tm = localtime (&d_t);
                            if (val[0] == '>') {
                        	UdmVarListReplaceStr(&Agent->Conf->Vars,"dt","er");
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dx","1");
                                sprintf (d_db, "%d", d_tm->tm_mday);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dd",d_db);
                                sprintf (d_db, "%d", d_tm->tm_mon);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dm",d_db);
                                sprintf (d_db, "%d", d_tm->tm_year+1900);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dy",d_db);
                                RETURN_TRUE;
                            } else if (val[0] == '<') {
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dt","er");
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dx","-1");
                                sprintf (d_db, "%d", d_tm->tm_mday);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dd",d_db);
                                sprintf (d_db, "%d", d_tm->tm_mon);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dm",d_db);
                                sprintf (d_db, "%d", d_tm->tm_year+1900);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dy",d_db);
                                RETURN_TRUE;
                            } else if ( (val[0]=='#') && (d_val2 = strchr(val,',')) ){
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"dt","range");
                                sprintf (d_db, "%d/%d/%d", d_tm->tm_mday, d_tm->tm_mon+1, d_tm->tm_year+1900);
                                d_t = atol (d_val2+1);
                                d_tm = localtime (&d_t);
                                sprintf (d_de, "%d/%d/%d", d_tm->tm_mday, d_tm->tm_mon+1, d_tm->tm_year+1900);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"db",d_db);
                                UdmVarListReplaceStr(&Agent->Conf->Vars,"de",d_de);
                                RETURN_TRUE;
                            } else {
                                php_error_docref(NULL TSRMLS_CC, E_WARNING,"Incorrect date limit format");
                                RETURN_FALSE;
                            }
                       }
#endif
			break;
		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown search limit parameter");
			RETURN_FALSE;
			break;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_clear_search_limits(int agent)
   Clear all mnoGoSearch search restrictions */
DLEXPORT PHP_FUNCTION(udm_clear_search_limits)
{
	pval ** yyagent;
	UDM_AGENT * Agent;
	int i;
	
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-Agent", le_link);
#if UDM_VERSION_ID >= 30204	
	for(i=0;i<Agent->Conf->Vars.nvars;i++){
		if ((!strcasecmp("ul",Agent->Conf->Vars.Var[i].name))||
		    (!strcasecmp("cat",Agent->Conf->Vars.Var[i].name))||
		    (!strcasecmp("t",Agent->Conf->Vars.Var[i].name))||
		    (!strcasecmp("lang",Agent->Conf->Vars.Var[i].name))) {
		    UDM_FREE(Agent->Conf->Vars.Var[i].name);
		    UDM_FREE(Agent->Conf->Vars.Var[i].val);
		    Agent->Conf->Vars.nvars--;
		}
	}
#else
	UdmClearLimits(Agent->Conf);
#endif	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_check_charset(int agent, string charset)
   Check if the given charset is known to mnogosearch */
DLEXPORT PHP_FUNCTION(udm_check_charset)
{
	pval ** yycharset, ** yyagent;
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yycharset)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yycharset);
	

	if (UdmGetCharSet(Z_STRVAL_PP(yycharset))) {
	    RETURN_TRUE;
	} else {
	    RETURN_FALSE;
	}	
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_crc32(int agent, string str)
   Return CRC32 checksum of gived string */
DLEXPORT PHP_FUNCTION(udm_crc32)
{
	pval ** yystr, ** yyagent;
	char *str;
	int crc32;
	char buf[32];
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yystr)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yystr);
	str = Z_STRVAL_PP(yystr);

	crc32=UdmCRC32((str),strlen(str));
	snprintf(buf,sizeof(buf)-1,"%u",crc32);
	
	RETURN_STRING(buf,1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_open_stored(int agent, string storedaddr)
   Open connection to stored  */
DLEXPORT PHP_FUNCTION(udm_open_stored)
{
	pval ** yyagent, ** yyaddr;
	
	int s;
	char * addr;
	const char *hello = "F\0";
	
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent, &yyaddr)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	
	convert_to_string_ex(yyaddr);
	addr = Z_STRVAL_PP(yyaddr);

	UdmReplaceStrVar(Agent->Conf->vars,"StoredAddr",addr,UDM_VARSRC_GLOBAL);
	Agent->Conf->stored_addr = strdup(UdmFindStrVar(Agent->Conf->vars, "StoredAddr", "localhost"));
	
	s = UdmStoreOpen(Agent->Conf);
	
	if (s >= 0) {
	    send(s, hello, 1, 0);
	    RETURN_LONG(s);
	} else RETURN_FALSE;	
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_close_stored(int agent, int link)
   Open connection to stored  */
DLEXPORT PHP_FUNCTION(udm_close_stored)
{
	pval ** yylink, ** yyagent;
	
	int s;
	unsigned int rec_id = 0;
	
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent, &yylink)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	
	convert_to_long_ex(yylink);
	s = Z_LVAL_PP(yylink);

	
	send(s, &rec_id, sizeof(rec_id), 0);
	closesocket(s);
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_check_stored(int agent, int link, string doc_id)
   Open connection to stored  */
DLEXPORT PHP_FUNCTION(udm_check_stored)
{
	pval ** yyid, ** yylink, ** yyagent;
	
	int s;
	unsigned int rec_id = 0;
	int store_found;
	
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 3: {
				if (zend_get_parameters_ex(3, &yyagent, &yylink, &yyid)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	
	convert_to_long_ex(yylink);
	s = Z_LVAL_PP(yylink);
	
	convert_to_string_ex(yyid);
	
	rec_id=strtoul(Z_STRVAL_PP(yyid),NULL,10);

	send(s, &rec_id, sizeof(rec_id), 0);
	if (UdmRecvAll(s, &store_found, sizeof(store_found), MSG_WAITALL) < 0) {
	    RETURN_LONG(store_found);
	} else RETURN_FALSE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_parse_query_string(int agent, string str)
   Parses query string, initialises variables and search limits taken from it */
DLEXPORT PHP_FUNCTION(udm_parse_query_string)
{
	pval ** yystr, ** yyagent;
	char *str;
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yystr)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yystr);
	str = Z_STRVAL_PP(yystr);

	UdmParseQueryString(Agent,&Agent->Conf->Vars,str);
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_make_excerpt(int agent, int res, int row)
   Perform search */
DLEXPORT PHP_FUNCTION(udm_make_excerpt)
{
	pval ** yyagent, **yyres, **yyrow_num;
	UDM_RESULT * Res;
	UDM_AGENT * Agent;
	int id=-1, row;

	switch(ZEND_NUM_ARGS()){
		case 3: {
				if (zend_get_parameters_ex(3, &yyagent, &yyres, &yyrow_num)==FAILURE) {
					RETURN_FALSE;
				}
				convert_to_string_ex(yyrow_num);
				row=atoi(Z_STRVAL_PP(yyrow_num));
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	ZEND_FETCH_RESOURCE(Res, UDM_RESULT *, yyres, -1, "mnoGoSearch-Result", le_res);
	
	if(row<Res->num_rows){
		char		*al;
		char		*Excerpt;
		
#if UDM_VERSION_ID >= 30216
		size_t		ExcerptSize, ExcerptPadding;
		
		ExcerptSize = (size_t)UdmVarListFindInt(&Agent->Conf->Vars, "ExcerptSize", 256);
		ExcerptPadding = (size_t)UdmVarListFindInt(&Agent->Conf->Vars, "ExcerptPadding", 40);
#endif	
	
		al = (char *)MyRemoveHiLightDup((const char *)(UdmVarListFindStr(&(Res->Doc[row].Sections), "URL", "")));
		UdmVarListReplaceInt(&(Res->Doc[row].Sections), "STORED_ID", UdmCRC32(al, strlen(al)));
		free(al);
		
#if UDM_VERSION_ID >= 30216
		Excerpt = UdmExcerptDoc(Agent, Res, &(Res->Doc[row]), ExcerptSize, ExcerptPadding);
#else
		Excerpt = UdmExcerptDoc(Agent, Res, &(Res->Doc[row]), 256);
#endif
		
		if ((Excerpt != NULL) && (strlen(Excerpt) > 6)) {
			char *HlExcerpt = UdmHlConvert(&Res->WWList, Excerpt, Agent->Conf->lcs, Agent->Conf->bcs);
			UdmVarListReplaceStr(&(Res->Doc[row].Sections),"Body",HlExcerpt);
			UDM_FREE(HlExcerpt);
		}
		if (Excerpt != NULL && (UdmVarListFindStr(&(Res->Doc[row].Sections), "Z", NULL) == NULL)) {
			UdmVarListReplaceInt(&(Res->Doc[row].Sections),"ST",1);
			UDM_FREE(Excerpt);
		} else {
		        UdmVarListReplaceInt(&(Res->Doc[row].Sections),"ST",0);
			RETURN_FALSE;
		}
	}else{
		php_error_docref(NULL TSRMLS_CC, E_WARNING,"row number too large");
		RETURN_FALSE;
	}
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_set_agent_param_ex(int agent, string var, string val)
   Set mnoGoSearch agent session parameters extended */
DLEXPORT PHP_FUNCTION(udm_set_agent_param_ex)
{
	pval **yyagent, **yyvar, **yyval;
	char *val, *var;
	UDM_AGENT * Agent;

	switch(ZEND_NUM_ARGS()){
	
		case 3: 		
			if(zend_get_parameters_ex(3,&yyagent,&yyvar,&yyval)==FAILURE){
				RETURN_FALSE;
			}
			convert_to_string_ex(yyvar);
			convert_to_string_ex(yyval);
			ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-agent", le_link);
			var = Z_STRVAL_PP(yyvar);
			val = Z_STRVAL_PP(yyval);
			
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	
	UdmVarListReplaceStr(&Agent->Conf->Vars,var,val);
	
	if (!strcasecmp(var,"LocalCharset")) {
		const char * charset=UdmVarListFindStr(&Agent->Conf->Vars,"LocalCharset","iso-8859-1");
		Agent->Conf->lcs=UdmGetCharSet(charset);
	} else if (!strcasecmp(var,"BrowserCharset")) {
		const char * charset=UdmVarListFindStr(&Agent->Conf->Vars,"BrowserCharset","iso-8859-1");
		Agent->Conf->bcs=UdmGetCharSet(charset);
	} else if (!strcasecmp(var,"Synonym")) {
		if (UdmSynonymListLoad(Agent->Conf,val)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s",Agent->Conf->errstr);
			RETURN_FALSE;
		} else UdmSynonymListSort(&(Agent->Conf->Synonyms));
	} else if (!strcasecmp(var,"Stopwordfile")) {
		if (UdmStopListLoad(Agent->Conf,val)) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "%s", Agent->Conf->errstr);
			RETURN_FALSE;
		}
	} else if (!strcasecmp(var,"MinWordLen")) {
		Agent->Conf->WordParam.min_word_len=atoi(val);
	} else if (!strcasecmp(var,"MaxWordLen")) {
		Agent->Conf->WordParam.max_word_len=atoi(val);
#if UDM_VERSION_ID <= 30207
	} else if (!strcasecmp(var,"VarDir")) {
		snprintf(Agent->Conf->vardir,sizeof(Agent->Conf->vardir)-1,"%s%s",val,UDMSLASHSTR);
#endif
	}

	RETURN_TRUE;
}

/* {{{ proto string udm_get_res_field_ex(int res, int row, string field)
   Fetch mnoGoSearch result field */
DLEXPORT PHP_FUNCTION(udm_get_res_field_ex)
{
	pval **yyres, **yyrow_num, **yyfield_name;

	UDM_RESULT * Res;
	int row;
	char *field;
	
	switch(ZEND_NUM_ARGS()){
		case 3: {
				if (zend_get_parameters_ex(3, &yyres,&yyrow_num,&yyfield_name)==FAILURE){
					RETURN_FALSE;
				}
				convert_to_string_ex(yyrow_num);
				convert_to_string_ex(yyfield_name);
				field = Z_STRVAL_PP(yyfield_name);
				row = atoi(Z_STRVAL_PP(yyrow_num));
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	
	ZEND_FETCH_RESOURCE(Res, UDM_RESULT *, yyres, -1, "mnoGoSearch-Result", le_res);
	if(row<Res->num_rows){
		if (!strcasecmp(field,"URL")) {
		    char	*al;
		    al = (char *)MyRemoveHiLightDup((const char *)(UdmVarListFindStr(&(Res->Doc[row].Sections), field, "")));
		    UdmVarListReplaceStr(&Res->Doc[row].Sections,field,al);
		    free(al);
		}
		RETURN_STRING((char *)UdmVarListFindStr(&Res->Doc[row].Sections,field,""),1);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING,"row number too large");
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_alloc_agent_array(array dbaddr)
   Allocate mnoGoSearch session */
DLEXPORT PHP_FUNCTION(udm_alloc_agent_array)
{
	switch(ZEND_NUM_ARGS()){

		case 1: {
				pval **yydbaddr;
				zval **tmp;
				char *dbaddr;
				UDM_ENV   * Env;
				UDM_AGENT * Agent;
				HashPosition   pos;
				
				if(zend_get_parameters_ex(1,&yydbaddr)==FAILURE){
					RETURN_FALSE;
				}
				
				if (Z_TYPE_PP(yydbaddr) != IS_ARRAY) {
				    	php_error_docref(NULL TSRMLS_CC, E_WARNING, "Argument DBAddr must be an array.");
					RETURN_FALSE;
				}
				convert_to_array_ex(yydbaddr);
				
				Env=UdmEnvInit(NULL);
				UdmVarListReplaceStr(&Env->Vars,"SyslogFacility","local7");
#if UDM_VERSION_ID >= 30215
				UdmSetLogLevel(NULL,0);
#else
				UdmSetLogLevel(Env,0);
#endif
				UdmOpenLog("mnoGoSearch-php",Env,0);
				
				zend_hash_internal_pointer_reset_ex(HASH_OF(*yydbaddr), &pos);
				
				while (zend_hash_get_current_data_ex(HASH_OF(*yydbaddr), (void **)&tmp, &pos) == SUCCESS) {
				    convert_to_string_ex(tmp);
				    dbaddr = Z_STRVAL_PP(tmp);
				    UdmDBListAdd(&Env->dbl,dbaddr, UDM_OPEN_MODE_WRITE);
				    
				    zend_hash_move_forward_ex(HASH_OF(*yydbaddr), &pos);
				}
				
				Agent=UdmAgentInit(NULL,Env,0);
				ZEND_REGISTER_RESOURCE(return_value,Agent,le_link);
			}
			break;
			
		default:
			WRONG_PARAM_COUNT;
			break;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_hash32(int agent, string str)
   Return Hash32 checksum of gived string */
DLEXPORT PHP_FUNCTION(udm_hash32)
{
	pval ** yystr, ** yyagent;
	char *str;
	udmhash32_t hash32;
	char buf[32];
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yystr)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:				
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yystr);
	str = Z_STRVAL_PP(yystr);

	hash32=UdmHash32((str),strlen(str));
#if UDM_VERSION_ID >= 30215
	snprintf(buf,sizeof(buf)-1,"%i",hash32);
#else
	snprintf(buf,sizeof(buf)-1,"%u",hash32);
#endif
	
	RETURN_STRING(buf,1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_find(int agent, string query)
   Perform search */
DLEXPORT PHP_FUNCTION(udm_find)
{
	pval ** yyquery, ** yyagent;
	UDM_RESULT * Res;
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
#if UDM_VERSION_ID >= 30213
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
#endif
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yyquery)==FAILURE) {
					RETURN_FALSE;
				}
				convert_to_string_ex(yyquery);
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	
#if UDM_VERSION_ID < 30200
	if ((Res=UdmFind(Agent,UdmTolower(Z_STRVAL_PP(yyquery),Agent->charset)))) {
#else
#if UDM_VERSION_ID >= 30213
	if ((Res=UdmFind(Agent))) {
#else
	if ((Res=UdmFind(Agent,Z_STRVAL_PP(yyquery)))) {
#endif
#endif	
	    ZEND_REGISTER_RESOURCE(return_value,Res,le_res);
	} else {
	    RETURN_FALSE;
	}	
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto string udm_get_res_field(int res, int row, int field)
   Fetch mnoGoSearch result field */
DLEXPORT PHP_FUNCTION(udm_get_res_field)
{
	pval **yyres, **yyrow_num, **yyfield_name;

	UDM_RESULT * Res;
	int row,field;
	
	switch(ZEND_NUM_ARGS()){
		case 3: {
				if (zend_get_parameters_ex(3, &yyres,&yyrow_num,&yyfield_name)==FAILURE){
					RETURN_FALSE;
				}
				convert_to_string_ex(yyrow_num);
				convert_to_string_ex(yyfield_name);
				field=atoi(Z_STRVAL_PP(yyfield_name));
				row=atoi(Z_STRVAL_PP(yyrow_num));
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Res, UDM_RESULT *, yyres, -1, "mnoGoSearch-Result", le_res);
	if(row<Res->num_rows){
		switch(field){
			case UDM_FIELD_URL: 		
#if UDM_VERSION_ID >= 30204
			    {
				char	*al;
				al = (char *)MyRemoveHiLightDup((const char *)(UdmVarListFindStr(&(Res->Doc[row].Sections), "URL", "")));
				UdmVarListReplaceStr(&Res->Doc[row].Sections,"URL",al);
				free(al);
				
				RETURN_STRING((char *)UdmVarListFindStr(&Res->Doc[row].Sections,"URL",""),1);
			    }
#else
				RETURN_STRING((Res->Doc[row].url)?(Res->Doc[row].url):"",1);
#endif
				break;
				
			case UDM_FIELD_CONTENT: 	
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Content-Type",""),1);
#else
				RETURN_STRING((Res->Doc[row].content_type)?(Res->Doc[row].content_type):"",1);
#endif
				break;
				
			case UDM_FIELD_TITLE:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Title",""),1);
#else
				RETURN_STRING((Res->Doc[row].title)?(Res->Doc[row].title):"",1);
#endif
				break;
				
			case UDM_FIELD_KEYWORDS:	
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Meta.Keywords",""),1);
#else
				RETURN_STRING((Res->Doc[row].keywords)?(Res->Doc[row].keywords):"",1);
#endif
				break;
				
			case UDM_FIELD_DESC:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Meta.Description",""),1);
#else
				RETURN_STRING((Res->Doc[row].description)?(Res->Doc[row].description):"",1);
#endif
				break;
				
			case UDM_FIELD_TEXT:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Body",""),1);
#else
				RETURN_STRING((Res->Doc[row].text)?(Res->Doc[row].text):"",1);
#endif
				break;
				
			case UDM_FIELD_SIZE:		
#if UDM_VERSION_ID >= 30204
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"Content-Length",0));
#else
				RETURN_LONG((Res->Doc[row].size));
#endif
				break;
				
			case UDM_FIELD_URLID:
#if UDM_VERSION_ID >= 30204
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"ID",0));
#else
				RETURN_LONG((Res->Doc[row].url_id));
#endif
				break;
				
			case UDM_FIELD_RATING:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Score",""),1);
#else
				RETURN_LONG((Res->Doc[row].rating));
#endif
				break;
				
			case UDM_FIELD_MODIFIED:	
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Last-Modified",""),1);
#else
				RETURN_LONG((Res->Doc[row].last_mod_time));
#endif
				break;

			case UDM_FIELD_ORDER:	
#if UDM_VERSION_ID >= 30204
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"Order",0));
#else
				RETURN_LONG((Res->Doc[row].order));
#endif
				break;
				
			case UDM_FIELD_CRC:	
#if UDM_VERSION_ID >= 30204
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"crc32",0));
#else
				RETURN_LONG((Res->Doc[row].crc32));
#endif
				break;
				
			case UDM_FIELD_CATEGORY:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Category",""),1);
#else
				RETURN_STRING((Res->Doc[row].category)?(Res->Doc[row].category):"",1);
#endif
				break;

#if UDM_VERSION_ID >= 30203		
			case UDM_FIELD_LANG:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Content-Language",""),1);
#else
				RETURN_STRING((Res->Doc[row].lang)?(Res->Doc[row].lang):"",1);
#endif
				break;

			case UDM_FIELD_CHARSET:		
#if UDM_VERSION_ID >= 30204
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Charset",""),1);
#else
				RETURN_STRING((Res->Doc[row].charset)?(Res->Doc[row].charset):"",1);
#endif
				break;
#endif			

#if UDM_VERSION_ID >= 30207
			case UDM_FIELD_SITEID:
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"Site_id",0));
				
				break;

			case UDM_FIELD_POP_RANK:
				RETURN_STRING((char *)UdmVarListFindStr(&(Res->Doc[row].Sections),"Pop_Rank",""),1);
				
				break;

			case UDM_FIELD_ORIGINID:
				RETURN_LONG(UdmVarListFindInt(&(Res->Doc[row].Sections),"Origin-Id",0));

				break;
#endif
				
			default: 
				php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown mnoGoSearch field name");
				RETURN_FALSE;
				break;
		}
	}else{
		php_error_docref(NULL TSRMLS_CC, E_WARNING,"row number too large");
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto string udm_get_res_param(int res, int param)
   Get mnoGoSearch result parameters */
DLEXPORT PHP_FUNCTION(udm_get_res_param)
{
	pval ** yyres, ** yyparam;
	int param;
	UDM_RESULT * Res;
	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyres, &yyparam)==FAILURE) {
					RETURN_FALSE;
				}
				convert_to_long_ex(yyparam);
				param=(Z_LVAL_PP(yyparam));
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Res, UDM_RESULT *, yyres, -1, "mnoGoSearch-Result", le_res);
	switch(param){
		case UDM_PARAM_NUM_ROWS: 	
			RETURN_LONG(Res->num_rows);
			break;
		
		case UDM_PARAM_FOUND:	 	
			RETURN_LONG(Res->total_found);
			break;
		
		case UDM_PARAM_WORDINFO: 
#if UDM_VERSION_ID >= 30204
			{
			    int len,i;
			    for(len = i = 0; i < Res->WWList.nwords; i++) 
				len += Res->WWList.Word[i].len + 64;
			    {	
				size_t wsize=(1+len)*sizeof(char);
				char *wordinfo = (char*) malloc(wsize);
	  
				*wordinfo = '\0';
	  
				for(i = 0; i < Res->WWList.nwords; i++){
				    if ((Res->WWList.Word[i].count > 0) || 
				        (Res->WWList.Word[i].origin == UDM_WORD_ORIGIN_QUERY)) {
					if(wordinfo[0]) strcat(wordinfo,", ");
					sprintf(UDM_STREND(wordinfo)," %s : %d", Res->WWList.Word[i].word, Res->WWList.Word[i].count);
				    } else if (Res->WWList.Word[i].origin == UDM_WORD_ORIGIN_STOP) {
					if(wordinfo[0]) strcat(wordinfo,", ");
					sprintf(UDM_STREND(wordinfo)," %s : stopword", Res->WWList.Word[i].word);
				    }
				}
				RETURN_STRING(wordinfo,1);
			    }
			}
#else
			RETURN_STRING((Res->wordinfo)?(Res->wordinfo):"",1);
#endif
			break;

#if UDM_VERSION_ID >= 30204
		case UDM_PARAM_WORDINFO_ALL: 
			{
			    int len,i,j;
			    for(len = i = 0; i < Res->WWList.nwords; i++) 
				len += Res->WWList.Word[i].len + 64;
			    {	
				size_t wsize=(1+len)*sizeof(char);
				char *wordinfo = (char*) malloc(wsize);
				int corder = (size_t)-1, ccount = 0;
	  
				*wordinfo = '\0';
				
				for(i = 0; i < Res->WWList.nwords; i++) {
				    corder = Res->WWList.Word[i].order;
				    ccount = 0;
				    for(j = 0; j < Res->WWList.nwords; j++) {
					if (Res->WWList.Word[j].order == corder) {
					    ccount += Res->WWList.Word[j].count;
				        }
				    }
				    if (Res->WWList.Word[i].origin == UDM_WORD_ORIGIN_STOP) {
					sprintf(UDM_STREND(wordinfo),"%s%s : stopword", (*wordinfo) ? ", " : "",  Res->WWList.Word[i].word);
				    } else if (Res->WWList.Word[i].origin == UDM_WORD_ORIGIN_QUERY) {
					sprintf(UDM_STREND(wordinfo),"%s%s : %d / %d", (*wordinfo) ? ", " : "", Res->WWList.Word[i].word, Res->WWList.Word[i].count, ccount);
				    } else continue;
				}
				RETURN_STRING(wordinfo,1);
			    }
			}
			break;
#endif
			
		case UDM_PARAM_SEARCHTIME: 	
			RETURN_DOUBLE(((double)Res->work_time)/1000);
			break;			
			
		case UDM_PARAM_FIRST_DOC:	 	
			RETURN_LONG(Res->first);
			break;

		case UDM_PARAM_LAST_DOC:	 	
			RETURN_LONG(Res->last);
			break;

		default:
			php_error_docref(NULL TSRMLS_CC, E_WARNING,"Unknown mnoGoSearch param name");
			RETURN_FALSE;
			break;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_free_res(int res)
   mnoGoSearch free result */
DLEXPORT PHP_FUNCTION(udm_free_res)
{
	pval ** yyres;
	UDM_RESULT * Res;
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyres)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Res, UDM_RESULT *, yyres, -1, "mnoGoSearch-Result", le_res);
	zend_list_delete(Z_LVAL_PP(yyres));
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_free_agent(int agent)
   Free mnoGoSearch session */
DLEXPORT PHP_FUNCTION(udm_free_agent)
{
	pval ** yyagent;
	UDM_RESULT * Agent;
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_RESULT *, yyagent, -1, "mnoGoSearch-agent", le_link);
	zend_list_delete(Z_LVAL_PP(yyagent));
	
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_errno(int agent)
   Get mnoGoSearch error number */
DLEXPORT PHP_FUNCTION(udm_errno)
{
	pval ** yyagent;
	UDM_AGENT * Agent;
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-Agent", le_link);
#if UDM_VERSION_ID >= 30208
	if (UdmEnvErrMsg(Agent->Conf) && strlen(UdmEnvErrMsg(Agent->Conf))) {
	    RETURN_LONG(1);
	} else {
	    RETURN_LONG(0);
	}
#elif UDM_VERSION_ID >= 30204
	RETURN_LONG(UdmEnvErrCode(Agent->Conf));
#else
	RETURN_LONG(UdmDBErrorCode(Agent->db));
#endif
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto string udm_error(int agent)
   Get mnoGoSearch error message */
DLEXPORT PHP_FUNCTION(udm_error)
{
	pval ** yyagent;
	UDM_AGENT * Agent;
	
	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, -1, "mnoGoSearch-Agent", le_link);
#if UDM_VERSION_ID >= 30204
	RETURN_STRING((UdmEnvErrMsg(Agent->Conf))?(UdmEnvErrMsg(Agent->Conf)):"",1);
#else
	RETURN_STRING((UdmDBErrorMsg(Agent->db))?(UdmDBErrorMsg(Agent->db)):"",1);
#endif
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_api_version()
   Get mnoGoSearch API version */
DLEXPORT PHP_FUNCTION(udm_api_version)
{
	RETURN_LONG(UDM_VERSION_ID);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto array udm_cat_list(int agent, string category)
   Get mnoGoSearch categories list with the same root */
DLEXPORT PHP_FUNCTION(udm_cat_list)
{
	pval ** yycat, ** yyagent;
	UDM_AGENT * Agent;
	char *cat;
#if UDM_VERSION_ID >= 30204	
	UDM_CATEGORY C;
#else	
	UDM_CATEGORY *c=NULL;
#endif
	char *buf=NULL;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yycat)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yycat);
	cat = Z_STRVAL_PP(yycat);

#if UDM_VERSION_ID >= 30204
	bzero(&C,sizeof(C));
	strncpy(C.addr,cat,sizeof(C.addr)-1);
#if UDM_VERSION_ID <= 30210
	if(!UdmCatAction(Agent,&C,UDM_CAT_ACTION_LIST,Agent->Conf->db)){
#else
	if(UDM_OK == UdmCatAction(Agent,&C,UDM_CAT_ACTION_LIST)){
#endif
#else
	if((c=UdmCatList(Agent,cat))){
#endif
		array_init(return_value);
		
		if (!(buf=calloc(1,UDMSTRSIZ+1))) {
			RETURN_FALSE;
		}
		
#if UDM_VERSION_ID >= 30204
		{
		    int i;
		    if (C.ncategories) {
			for(i=0;i<C.ncategories;i++){
			    add_next_index_stringl(return_value, C.Category[i].path,strlen(C.Category[i].path),1);
			    add_next_index_stringl(return_value, C.Category[i].name,strlen(C.Category[i].name),1);
			}
		    } else {
			RETURN_FALSE;
		    }
		}
#else
		while(c->rec_id){			
			snprintf(buf, UDMSTRSIZ, "%s%s",c->link[0]?"@ ":"", c->name);				 
			add_next_index_string(return_value, c->link[0]?c->link:c->path, 1);
			add_next_index_string(return_value, buf, 1);
			c++;
		}
#endif		
		free(buf);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto array udm_cat_path(int agent, string category)
   Get mnoGoSearch categories path from the root to the given catgory */
DLEXPORT PHP_FUNCTION(udm_cat_path)
{
	pval ** yycat, ** yyagent;
	UDM_AGENT * Agent;
	char *cat;
#if UDM_VERSION_ID >= 30204	
	UDM_CATEGORY C;
#else	
	UDM_CATEGORY *c=NULL;
#endif
	char *buf=NULL;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 2: {
				if (zend_get_parameters_ex(2, &yyagent,&yycat)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
	convert_to_string_ex(yycat);
	cat = Z_STRVAL_PP(yycat);

#if UDM_VERSION_ID >= 30204
	bzero(&C,sizeof(C));
	strncpy(C.addr,cat,sizeof(C.addr)-1);
#if UDM_VERSION_ID <= 30210
	if(!UdmCatAction(Agent,&C,UDM_CAT_ACTION_PATH,Agent->Conf->db)){
#else
	if(UDM_OK == UdmCatAction(Agent,&C,UDM_CAT_ACTION_PATH)){
#endif
#else
	if((c=UdmCatPath(Agent,cat))){
#endif
		array_init(return_value);
		
		if (!(buf=calloc(1,UDMSTRSIZ+1))) {
			RETURN_FALSE;
		}
		
#if UDM_VERSION_ID >= 30204
		{
		    int i;
		    if (C.ncategories) {
			for(i=0;i<C.ncategories;i++){			
			    add_next_index_stringl(return_value, C.Category[i].path,strlen(C.Category[i].path),1);
			    add_next_index_stringl(return_value, C.Category[i].name,strlen(C.Category[i].name),1);
			}
		    } else {
			RETURN_FALSE;
		    }
		}
#else
		while(c->rec_id){			
			snprintf(buf, UDMSTRSIZ, "%s%s",c->link[0]?"@ ":"", c->name);				 
			add_next_index_string(return_value, c->link[0]?c->link:c->path, 1);
			add_next_index_string(return_value, buf, 1);
			c++;
		}
#endif		
		free(buf);
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\mnogosearch\php_mnogo.c"
/* {{{ proto int udm_get_doc_count(int agent)
   Get total number of documents in database */
DLEXPORT PHP_FUNCTION(udm_get_doc_count)
{
	pval ** yyagent;
	UDM_AGENT * Agent;
	int id=-1;

	switch(ZEND_NUM_ARGS()){
		case 1: {
				if (zend_get_parameters_ex(1, &yyagent)==FAILURE) {
					RETURN_FALSE;
				}
			}
			break;
		default:
			WRONG_PARAM_COUNT;
			break;
	}
	ZEND_FETCH_RESOURCE(Agent, UDM_AGENT *, yyagent, id, "mnoGoSearch-Agent", le_link);
#if UDM_VERSION_ID >= 30204
#if UDM_VERSION_ID <= 30210
	if (!Agent->doccount) UdmURLAction(Agent,NULL,UDM_URL_ACTION_DOCCOUNT,Agent->Conf->db);
#else
	if (!Agent->doccount) UdmURLAction(Agent,NULL,UDM_URL_ACTION_DOCCOUNT);
#endif
	RETURN_LONG(Agent->doccount);
#else
	RETURN_LONG(UdmGetDocCount(Agent));
#endif
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\ncurses\ncurses_functions.c"
/* {{{ proto int ncurses_filter(void)
 */
PHP_FUNCTION(ncurses_filter)
{
	IS_NCURSES_INITIALIZED();
	filter();
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\notes\php_notes.c"
/* {{{ proto string notes_search(string database_name, string keywords)
   Finds notes that match keywords in database_name.  The note(s) that are returned must be converted to base 16. Example base_convert($note_id, "10", "16") */

STATUS LNPUBLIC file_action (void *, SEARCH_MATCH *, ITEM_TABLE *);
STATUS LNPUBLIC print_file_summary (ITEM_TABLE *);


PHP_FUNCTION(notes_search)
{

	int argc;
	pval *argv[2];
	STATUS error;
	DBHANDLE db_handle;
    HANDLE search_handle;         /* handle to a search */
	pval **db;
	pval **keywords;
	char		error_string[200];
    FT_INDEX_STATS Stats;   /* statistics from FTIndex */
    DWORD RetDocs;        /* number of documents returned by the search */
    HANDLE SearchResults_handle;  /* handle to the results of the search */
    FT_SEARCH_RESULTS *pSearchResults;    /* pointer to the results of the search */
    HANDLE IDTable_handle;        /* handle to id table built with found NOTEIDs */
    NOTEID *pNoteID;        /* pointer to the NOTEIDs found */
    BYTE *pScores;          /* pointer to the scores */
    DWORD i;
   
	argc = ARG_COUNT(ht);

	if (getParametersArray(ht, argc, argv) == FAILURE){

		WRONG_PARAM_COUNT;
	}

	if (zend_get_parameters_ex(2, &db, &keywords)==FAILURE) {
		RETURN_FALSE;
	}

	convert_to_string_ex(db);
	convert_to_string_ex(keywords);
	
	error = NotesInitExtended( argc, (char **) argv );

	if( error ){

		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Unable to initialize Lotus Notes: %s", error_string);
		RETURN_FALSE;
	}
	
	if (error = NSFDbOpen (Z_STRVAL_PP(db), &db_handle)){
	
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Unable to open database: %s", error_string);
		NotesTerm();
		RETURN_FALSE;
	}

	error = FTIndex(db_handle, FT_INDEX_AUTOOPTIONS, NULL, &Stats);
	if (error){

		NSFDbClose (db_handle);
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Unable to search database: %s", error_string);
		NotesTerm();
		RETURN_FALSE;
	}

   if (error = FTOpenSearch(&search_handle)){

		NSFDbClose (db_handle);
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Unable to open search: %s", error_string);
		NotesTerm();
		RETURN_FALSE;
   }

   /* do the search on the query */
   error = FTSearch (db_handle,                  /* database handle */
                     &search_handle,             /* pointer to previously 
                                              allocated search handle */
                     (HCOLLECTION) NULLHANDLE, /* no collection specified - 
                                              query all docs */
                     Z_STRVAL_PP(keywords),                /* query string */
                     FT_SEARCH_SCORES |    /* find relevancy scores */
                     FT_SEARCH_STEM_WORDS, /* find word variants */
                     0,                    /* maximum number of docs to
                                              return; 0 = unlimited */
                     NULLHANDLE,           /* no refining IDTABLE   */
                     &RetDocs,           /* returned number of docs */
                     NULL,                 /* reserved */
                     &SearchResults_handle);     /* returned info */
   if (error){

		FTCloseSearch (search_handle);
		NSFDbClose (db_handle);
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Error during searchkkk: %s", error_string);
		NotesTerm();
		RETURN_FALSE;
   }

   /* return if no document in the result */
   if (RetDocs == 0 )
   {
		php_printf("\n0 documents returned \n");
		FTCloseSearch (search_handle);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   pSearchResults = OSLock (FT_SEARCH_RESULTS, SearchResults_handle);

   /* Create an IDTABLE to further refine our search */

   if (error = IDCreateTable(sizeof(NOTEID), &IDTable_handle))
   {
		FTCloseSearch (search_handle);
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Error creating ID table: %s", error_string);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   /* set up a pointer to the array of note id's that occur after
   the FT_SEARCH_RESULTS structure */

   pNoteID = (NOTEID *) (((char *) pSearchResults)
       + sizeof(FT_SEARCH_RESULTS));

   pScores = (BYTE *) (pNoteID + pSearchResults->NumHits);
   for (i = 0; i < pSearchResults->NumHits; i++, pNoteID++, pScores++)
   {
      /* save the note ids in the IDTABLE */

      if (error = IDInsert (IDTable_handle, *pNoteID, NULL))
      {

        OSUnlockObject(SearchResults_handle);
        OSMemFree (SearchResults_handle);
        FTCloseSearch (search_handle);
        IDDestroyTable (IDTable_handle);
		OSLoadString(NULLHANDLE, ERR(error), error_string, sizeof(error_string));
		php_error(E_WARNING,"Error saving note to ID table: %s", error_string);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
      }
   }

   OSUnlockObject(SearchResults_handle);
   OSMemFree (SearchResults_handle);

   if (error = FTCloseSearch(search_handle))
   {
        IDDestroyTable (IDTable_handle);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   if (error = FTOpenSearch(&search_handle))
   {
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   /* do the refined search on the query with no word variants */

   error = FTSearch (db_handle,                  /* database handle */
                     &search_handle,             /* pointer to previously 
                                              allocated search handle */
                     (HCOLLECTION) NULLHANDLE, /* no collection specified - 
                                              query all docs */
                     Z_STRVAL_PP(keywords),                /* query string */
                     FT_SEARCH_SCORES |    /* find relevancy scores */
                     FT_SEARCH_REFINE,     /* refine the search - use the
                                            * given id table */
                     0,                    /* maximum number of docs to
                                              return; 0 = unlimited */
                     IDTable_handle,             /* refining IDTABLE   */
                     &RetDocs,           /* returned number of docs */
                     NULL,                 /* reserved */
                     &SearchResults_handle);     /* returned info */
   if (error)
   {
		FTCloseSearch (search_handle);
		IDDestroyTable (IDTable_handle);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   /* return if no document in the result */
   if (RetDocs == 0 )
   {
		php_printf("\n0 documents returned \n");
		FTCloseSearch (search_handle);
		IDDestroyTable (IDTable_handle);
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   /* obtain a pointer to the search results */
   pSearchResults = OSLock (FT_SEARCH_RESULTS, SearchResults_handle);

   /* set up a pointer to the array of note id's that occur after
      the FT_SEARCH_RESULTS structure */

   pNoteID = (NOTEID *) (((char *) pSearchResults)
           + sizeof(FT_SEARCH_RESULTS));
   
   /* pSearchResults->NumHits */
   array_init(return_value);

   pScores = (BYTE *) (pNoteID + pSearchResults->NumHits);
   for (i = 0; i < pSearchResults->NumHits; i++, pNoteID++, pScores++){

	    add_next_index_long(return_value, (long) *pNoteID );
		/* RETVAL_LONG( (long) *pNoteID ); */
   }

   OSUnlockObject (SearchResults_handle);
   OSMemFree (SearchResults_handle);
   IDDestroyTable (IDTable_handle);

   if (error = FTCloseSearch(search_handle))
   {
		NSFDbClose (db_handle);
		NotesTerm();
		RETURN_FALSE;
   }

   NSFDbClose (db_handle);
   NotesTerm();
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto int birdstep_connect(string server, string user, string pass)
 */
PHP_FUNCTION(birdstep_connect)
{
	zval **serv,**user,**pass;
	char *Serv = NULL;
	char *User = NULL;
	char *Pass = NULL;
	RETCODE stat;
	HDBC hdbc;
	VConn *new;
	long ind;

	if ( php_birdstep_module.max_links != -1 && php_birdstep_module.num_links == php_birdstep_module.max_links ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Too many open connections (%d)",php_birdstep_module.num_links);
		RETURN_FALSE;
	}
	if (ZEND_NUM_ARGS() != 3 || zend_get_parameters_ex(3, &serv, &user, &pass) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(serv);
	convert_to_string_ex(user);
	convert_to_string_ex(pass);
	Serv = Z_STRVAL_PP(serv);
	User = Z_STRVAL_PP(user);
	Pass = Z_STRVAL_PP(pass);
	stat = SQLAllocConnect(henv,&hdbc);
	if ( stat != SQL_SUCCESS ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Could not allocate connection handle");
		RETURN_FALSE;
	}
	stat = SQLConnect(hdbc,Serv,SQL_NTS,User,SQL_NTS,Pass,SQL_NTS);
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Could not connect to server \"%s\" for %s",Serv,User);
		SQLFreeConnect(hdbc);
		RETURN_FALSE;
	}
	new = (VConn *)emalloc(sizeof(VConn));
	ind = birdstep_add_conn(list,new,hdbc);
	php_birdstep_module.num_links++;
	RETURN_LONG(ind);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_close(int id)
 */
PHP_FUNCTION(birdstep_close)
{
	zval **id;
	VConn *conn;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &id) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(id);

	SQLDisconnect(conn->hdbc);
	SQLFreeConnect(conn->hdbc);
	birdstep_del_conn(list,Z_LVAL_PP(id));
	php_birdstep_module.num_links--;
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto int birdstep_exec(int index, string exec_str)
 */
PHP_FUNCTION(birdstep_exec)
{
	zval **ind, **exec_str;
	char *query = NULL;
	int indx;
	VConn *conn;
	Vresult *res;
	RETCODE stat;
	SWORD cols,i,colnamelen;
	SDWORD rows,coldesc;

	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &ind, &exec_str) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(ind);

	convert_to_string_ex(exec_str);
	query = Z_STRVAL_PP(exec_str);

	res = (Vresult *)emalloc(sizeof(Vresult));
	stat = SQLAllocStmt(conn->hdbc,&res->hstmt);
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLAllocStmt return %d",stat);
		efree(res);
		RETURN_FALSE;
	}
	stat = SQLExecDirect(res->hstmt,query,SQL_NTS);
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Can not execute \"%s\" query",query);
		SQLFreeStmt(res->hstmt,SQL_DROP);
		efree(res);
		RETURN_FALSE;
	}
	/* Success query */
	stat = SQLNumResultCols(res->hstmt,&cols);
	if ( stat != SQL_SUCCESS ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLNumResultCols return %d",stat);
		SQLFreeStmt(res->hstmt,SQL_DROP);
		efree(res);
		RETURN_FALSE;
	}
	if ( !cols ) { /* Was INSERT, UPDATE, DELETE, etc. query */
		stat = SQLRowCount(res->hstmt,&rows);
		if ( stat != SQL_SUCCESS ) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLNumResultCols return %d",stat);
			SQLFreeStmt(res->hstmt,SQL_DROP);
			efree(res);
			RETURN_FALSE;
		}
		SQLFreeStmt(res->hstmt,SQL_DROP);
		efree(res);
		RETURN_LONG(rows);
	} else {  /* Was SELECT query */
		res->values = (VResVal *)emalloc(sizeof(VResVal)*cols);
		res->numcols = cols;
		for ( i = 0; i < cols; i++ ) {
			SQLColAttributes(res->hstmt,i+1,SQL_COLUMN_NAME,
			   res->values[i].name,sizeof(res->values[i].name),
			   &colnamelen,NULL);
			SQLColAttributes(res->hstmt,i+1,SQL_COLUMN_TYPE,
			   NULL,0,NULL,&res->values[i].valtype);
			switch ( res->values[i].valtype ) {
				case SQL_LONGVARBINARY:
				case SQL_LONGVARCHAR:
					res->values[i].value = NULL;
					continue;
				default:
					break;
			}
			SQLColAttributes(res->hstmt,i+1,SQL_COLUMN_DISPLAY_SIZE,
			   NULL,0,NULL,&coldesc);
			res->values[i].value = (char *)emalloc(coldesc+1);
			SQLBindCol(res->hstmt,i+1,SQL_C_CHAR, res->values[i].value,coldesc+1, &res->values[i].vallen);
		}
	}
	res->fetched = 0;
	indx = birdstep_add_result(list,res,conn);
	RETURN_LONG(indx);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_fetch(int index)
 */
PHP_FUNCTION(birdstep_fetch)
{
	zval **ind;
	Vresult *res;
	RETCODE stat;
	UDWORD  row;
	UWORD   RowStat[1];

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &ind) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_GET_BIRDSTEP_RES_IDX(ind);

	stat = SQLExtendedFetch(res->hstmt,SQL_FETCH_NEXT,1,&row,RowStat);
	if ( stat == SQL_NO_DATA_FOUND ) {
		SQLFreeStmt(res->hstmt,SQL_DROP);
		birdstep_del_result(list,Z_LVAL_PP(ind));
		RETURN_FALSE;
	}
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLFetch return error");
		SQLFreeStmt(res->hstmt,SQL_DROP);
		birdstep_del_result(list,Z_LVAL_PP(ind));
		RETURN_FALSE;
	}
	res->fetched = 1;
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto mixed birdstep_result(int index, int col)
 */
PHP_FUNCTION(birdstep_result)
{
	zval **ind, **col;
	Vresult *res;
	RETCODE stat;
	int i,sql_c_type;
	UDWORD row;
	UWORD RowStat[1];
	SWORD indx = -1;
	char *field = NULL;

	if ( ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &ind, &col) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_GET_BIRDSTEP_RES_IDX(ind);

	if ( Z_TYPE_PP(col) == IS_STRING ) {
		field = Z_STRVAL_PP(col);
	} else {
		convert_to_long_ex(col);
		indx = Z_LVAL_PP(col);
	}
	if ( field ) {
		for ( i = 0; i < res->numcols; i++ ) {
			if ( !strcasecmp(res->values[i].name,field)) {
				indx = i;
				break;
			}
		}
		if ( indx < 0 ) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING,  "Field %s not found",field);
			RETURN_FALSE;
		}
	} else {
		if ( indx < 0 || indx >= res->numcols ) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Field index not in range");
			RETURN_FALSE;
		}
	}
	if ( !res->fetched ) {
		stat = SQLExtendedFetch(res->hstmt,SQL_FETCH_NEXT,1,&row,RowStat);
		if ( stat == SQL_NO_DATA_FOUND ) {
			SQLFreeStmt(res->hstmt,SQL_DROP);
			birdstep_del_result(list,Z_LVAL_PP(ind));
			RETURN_FALSE;
		}
		if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLFetch return error");
			SQLFreeStmt(res->hstmt,SQL_DROP);
			birdstep_del_result(list,Z_LVAL_PP(ind));
			RETURN_FALSE;
		}
		res->fetched = 1;
	}
	switch ( res->values[indx].valtype ) {
		case SQL_LONGVARBINARY:
			sql_c_type = SQL_C_BINARY;
			goto l1;
		case SQL_LONGVARCHAR:
			sql_c_type = SQL_C_CHAR;
l1:
			if ( !res->values[indx].value ) {
				res->values[indx].value = emalloc(4096);
			}
			stat = SQLGetData(res->hstmt,indx+1,sql_c_type,
				res->values[indx].value,4095,&res->values[indx].vallen);
			if ( stat == SQL_NO_DATA_FOUND ) {
				SQLFreeStmt(res->hstmt,SQL_DROP);
				birdstep_del_result(list,Z_LVAL_PP(ind));
				RETURN_FALSE;
			}
			if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: SQLGetData return error");
				SQLFreeStmt(res->hstmt,SQL_DROP);
				birdstep_del_result(list,Z_LVAL_PP(ind));
				RETURN_FALSE;
			}
			if ( res->values[indx].valtype == SQL_LONGVARCHAR ) {
				RETURN_STRING(res->values[indx].value,TRUE);
			} else {
				RETURN_LONG((long)res->values[indx].value);
			}
		default:
			if ( res->values[indx].value != NULL ) {
				RETURN_STRING(res->values[indx].value,TRUE);
			}
	}
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_freeresult(int index)
 */
PHP_FUNCTION(birdstep_freeresult)
{
	zval **ind;
	Vresult *res;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &ind) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_GET_BIRDSTEP_RES_IDX(ind);

	SQLFreeStmt(res->hstmt,SQL_DROP);
	birdstep_del_result(list,Z_LVAL_PP(ind));
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_autocommit(int index)
 */
PHP_FUNCTION(birdstep_autocommit)
{
	zval **id;
	RETCODE stat;
	VConn *conn;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &id) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(id);

	stat = SQLSetConnectOption(conn->hdbc,SQL_AUTOCOMMIT,SQL_AUTOCOMMIT_ON);
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Set autocommit_on option failure");
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_off_autocommit(int index)
 */
PHP_FUNCTION(birdstep_off_autocommit)
{
	zval **id;
	RETCODE stat;
	VConn *conn;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &id) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(id);

	stat = SQLSetConnectOption(conn->hdbc,SQL_AUTOCOMMIT,SQL_AUTOCOMMIT_OFF);
	if ( stat != SQL_SUCCESS && stat != SQL_SUCCESS_WITH_INFO ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Set autocommit_off option failure");
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_commit(int index)
 */
PHP_FUNCTION(birdstep_commit)
{
	zval **id;
	RETCODE stat;
	VConn *conn;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &id) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(id)

	stat = SQLTransact(NULL,conn->hdbc,SQL_COMMIT);
	if ( stat != SQL_SUCCESS ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Commit failure");
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto bool birdstep_rollback(int index)
 */
PHP_FUNCTION(birdstep_rollback)
{
	zval **id;
	RETCODE stat;
	VConn *conn;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &id) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_BIRDSTEP_CHK_LNK(id);

	stat = SQLTransact(NULL,conn->hdbc,SQL_ROLLBACK);
	if ( stat != SQL_SUCCESS ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Rollback failure");
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto string birdstep_fieldname(int index, int col)
 */
PHP_FUNCTION(birdstep_fieldname)
{
	zval **ind, **col;
	Vresult *res;
	SWORD indx;

	if ( ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &ind, &col) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_GET_BIRDSTEP_RES_IDX(ind);

	convert_to_long_ex(col);
	indx = Z_LVAL_PP(col);
	if ( indx < 0 || indx >= res->numcols ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Birdstep: Field index not in range");
		RETURN_FALSE;
	}
	RETURN_STRING(res->values[indx].name,TRUE);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\birdstep.c"
/* {{{ proto int birdstep_fieldnum(int index)
 */
PHP_FUNCTION(birdstep_fieldnum)
{
	zval **ind;
	Vresult *res;

	if ( ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &ind) == FAILURE ) {
		WRONG_PARAM_COUNT;
	}
	PHP_GET_BIRDSTEP_RES_IDX(ind);

	RETURN_LONG(res->numcols);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\odbc\php_odbc.c"
/* {{{ proto bool solid_fetch_prev(resource result_id)
   */ 
#if defined(HAVE_SOLID) || defined(HAVE_SOLID_30) || defined(HAVE_SOLID_35)
PHP_FUNCTION(solid_fetch_prev)
{
	odbc_result *result;
	RETCODE rc;
	pval **pv_res;
	
	if (zend_get_parameters_ex(1, &pv_res) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	
	ZEND_FETCH_RESOURCE(result, odbc_result *, pv_res, -1, "ODBC result", le_result);
	if (result->numcols == 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "No tuples available at this result index");
		RETURN_FALSE;
	}
	rc = SQLFetchPrev(result->stmt);

	if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO) {
		RETURN_FALSE;
	}

	if (result->fetched > 1) result->fetched--;

	RETURN_TRUE;
}
#endif
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\readline\readline.c"
/* {{{ proto void readline_completion_function(string funcname) 
   Readline completion function? */

static char *_readline_command_generator(char *text,int state)
{
	HashTable  *myht = Z_ARRVAL(_readline_array);
	zval **entry;
	
	if (! state)	{
		zend_hash_internal_pointer_reset(myht);
	}
	
	while (zend_hash_get_current_data(myht, (void **)&entry) == SUCCESS) {
		zend_hash_move_forward(myht);

		convert_to_string_ex(entry);
		if (strncmp (Z_STRVAL_PP(entry), text, strlen(text)) == 0) {
			return (strdup(Z_STRVAL_PP(entry)));
		}
	}

	return NULL;
}

static zval *_readline_string_zval(const char *str)
{
	zval *ret;
	int len = strlen(str);
	MAKE_STD_ZVAL(ret);

	Z_TYPE_P(ret) = IS_STRING;
	Z_STRLEN_P(ret) = len;
	Z_STRVAL_P(ret) = estrndup(str, len);
	return ret;
}

static zval *_readline_long_zval(long l)
{
	zval *ret;
	MAKE_STD_ZVAL(ret);

	Z_TYPE_P(ret) = IS_LONG;
	Z_LVAL_P(ret) = l;
	return ret;
}

static char **_readline_completion_cb(char *text, int start, int end)
{ 
	zval *params[4];
	int i;
	char **matches = NULL;
	TSRMLS_FETCH();

	params[0]=_readline_string_zval(_readline_completion);
	params[1]=_readline_string_zval(text);
	params[2]=_readline_long_zval(start);
	params[3]=_readline_long_zval(end);

	if (call_user_function(CG(function_table), NULL, params[0], &_readline_array, 3, params+1 TSRMLS_CC) == SUCCESS) {
		if (Z_TYPE(_readline_array) == IS_ARRAY) {
			if (zend_hash_num_elements(Z_ARRVAL(_readline_array))) {
				matches = completion_matches(text,_readline_command_generator);
			} else {
				matches = malloc(sizeof(char *) * 2);
				matches[0] = strdup("");
				matches[1] = '\0';
			}
		}
	}
	
	for (i = 0; i < 4; i++) {
		zval_ptr_dtor(&params[i]);
	}
	zval_dtor(&_readline_array);
	
	return matches; 
}

PHP_FUNCTION(readline_completion_function)
{
	pval **arg;
	int ac = ZEND_NUM_ARGS();

	if (ac < 0 || ac > 1 || zend_get_parameters_ex(ac, &arg) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	if (ac == 1) {
		convert_to_string_ex(arg);

		if (_readline_completion)
			efree(_readline_completion);

		_readline_completion = estrdup(Z_STRVAL_PP(arg));
		rl_attempted_completion_function = _readline_completion_cb;
	}

	RETURN_TRUE;
}

/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\snmp\snmp.c"
/* {{{ proto void php_snmpv3(INTERNAL_FUNCTION_PARAMETERS, int st)
*
* Generic SNMPv3 object fetcher
* From here is passed on the the common internal object fetcher.
*
* st=1   snmp3_get() - query an agent and return a single value.
* st=2   snmp3_walk() - walk the mib and return a single dimensional array 
*                       containing the values.
* st=3   snmp3_real_walk() - walk the mib and return an 
*                            array of oid,value pairs.
* st=11  snmp3_set() - query an agent and set a single value
*
*/
static void php_snmpv3(INTERNAL_FUNCTION_PARAMETERS, int st)
{
	zval **a1, **a2, **a3, **a4, **a5, **a6, **a7, **a8, **a9, **a10, **a11, **a12;
	struct snmp_session session;
	long timeout=SNMP_DEFAULT_TIMEOUT;
	long retries=SNMP_DEFAULT_RETRIES;
	int myargc = ZEND_NUM_ARGS();
	char type = (char) 0;
	char *value = (char *) 0;
	char hostname[MAX_NAME_LEN];
	int remote_port = 161;
	char *pptr;

	if (myargc < 8 || myargc > 12 ||
		zend_get_parameters_ex(myargc, &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	snmp_sess_init(&session);
	/* This is all SNMPv3 */
	session.version = SNMP_VERSION_3;

	/* Reading the hostname and its optional non-default port number */
	convert_to_string_ex(a1);
	strlcpy(hostname, Z_STRVAL_PP(a1), sizeof(hostname));
	if ((pptr = strchr (hostname, ':'))) {
		remote_port = strtol (pptr + 1, NULL, 0);
	}
	session.peername = hostname;
	session.remote_port = remote_port;

	/* Setting the security name. */
	convert_to_string_ex(a2);
	if (netsnmp_session_set_sec_name(&session, Z_STRVAL_PP(a2))) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could net set security name: %s", Z_STRVAL_PP(a2));
		RETURN_FALSE;
	}

	/* Setting the security level. */
	convert_to_string_ex(a3);
	if (netsnmp_session_set_sec_level(&session, Z_STRVAL_PP(a3) TSRMLS_CC)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid security level: %s", Z_STRVAL_PP(a3));
		RETURN_FALSE;
	}

	/* Setting the authentication protocol. */
	convert_to_string_ex(a4);
	if (netsnmp_session_set_auth_protocol(&session, Z_STRVAL_PP(a4) TSRMLS_CC)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid authentication protocol: %s", Z_STRVAL_PP(a4));
		RETURN_FALSE;
	}
	/* Setting the authentication passphrase. */
	convert_to_string_ex(a5);
	if (netsnmp_session_gen_auth_key(&session, Z_STRVAL_PP(a5) TSRMLS_CC)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not generate key for authentication pass phrase: %s", Z_STRVAL_PP(a4));
		RETURN_FALSE;
	}

	/* Setting the security protocol. */
	convert_to_string_ex(a6);
	if (netsnmp_session_set_sec_protocol(&session, Z_STRVAL_PP(a6) TSRMLS_CC) &&
			(0 != strlen(Z_STRVAL_PP(a6)))) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid security protocol: %s", Z_STRVAL_PP(a6));
		RETURN_FALSE;
	}
	/* Setting the security protocol passphrase. */
	convert_to_string_ex(a7);
	if (netsnmp_session_gen_sec_key(&session, Z_STRVAL_PP(a7) TSRMLS_CC) &&
							(0 != strlen(Z_STRVAL_PP(a7)))) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not generate key for security pass phrase: %s", Z_STRVAL_PP(a7));
		RETURN_FALSE;
	}

	if (st == 11) {
		if (myargc < 10) {
			WRONG_PARAM_COUNT;
		}
		if (myargc > 10) {
			convert_to_long_ex(a11);
			timeout = Z_LVAL_PP(a11);
		}
		if (myargc > 11) {
			convert_to_long_ex(a12);
			retries = Z_LVAL_PP(a12);
		}
		convert_to_string_ex(a9);
		convert_to_string_ex(a10);
		type = Z_STRVAL_PP(a9)[0];
		value = Z_STRVAL_PP(a10);
	} else {
		if (myargc > 8) {
			convert_to_long_ex(a9);
			timeout = Z_LVAL_PP(a9);
		}
		if (myargc > 9) {
			convert_to_long_ex(a10);
			retries = Z_LVAL_PP(a10);
		}
	}

	session.retries = retries;
	session.timeout = timeout;

	php_snmp_internal(INTERNAL_FUNCTION_PARAM_PASSTHRU, st, &session, Z_STRVAL_PP(a8), type, value);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate(object obj, string class)
   */
PHP_FUNCTION(aggregate)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_ALL, AGGREGATE_ALL);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_methods(object obj, string class)
   */
PHP_FUNCTION(aggregate_methods)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_METHODS, AGGREGATE_ALL);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_methods_by_list(object obj, string class, array method_list [, bool exclude])
   */
PHP_FUNCTION(aggregate_methods_by_list)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_METHODS, AGGREGATE_BY_LIST);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_properties(object obj, string class)
   */
PHP_FUNCTION(aggregate_properties)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_PROPERTIES, AGGREGATE_ALL);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_properties_by_list(object obj, string class, array props_list [, bool exclude])
   */
PHP_FUNCTION(aggregate_properties_by_list)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_PROPERTIES, AGGREGATE_BY_LIST);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_methods_by_regexp(object obj, string class, string regexp [, bool exclude])
   */
PHP_FUNCTION(aggregate_methods_by_regexp)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_METHODS, AGGREGATE_BY_REGEXP);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void aggregate_properties_by_regexp(object obj, string class, string regexp [, bool exclude])
   */
PHP_FUNCTION(aggregate_properties_by_regexp)
{
	aggregate(INTERNAL_FUNCTION_PARAM_PASSTHRU, AGGREGATE_PROPERTIES, AGGREGATE_BY_REGEXP);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto array aggregation_info(object obj)
 */
PHP_FUNCTION(aggregation_info)
{
	zval *obj;
	aggregation_info *aggr_info;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "o", &obj) == FAILURE) {
		return;
	}

	if (!BG(aggregation_table) ||
		zend_hash_index_find(BG(aggregation_table), (long)obj, (void**)&aggr_info) == FAILURE) {
		RETURN_FALSE;
	}

	*return_value = *aggr_info->aggr_members;
	zval_copy_ctor(return_value);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\aggregation.c"
/* {{{ proto void deaggregate(object obj [, string class])
 */
PHP_FUNCTION(deaggregate)
{
	zval *obj;
	char *class_name = NULL, *class_name_lc;
	int class_name_len;
	aggregation_info *aggr_info;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "o|s", &obj,
							  &class_name, &class_name_len) == FAILURE) {
		return;
	}

	if (!BG(aggregation_table) ||
		zend_hash_index_find(BG(aggregation_table), (long)obj, (void**)&aggr_info) == FAILURE) {
		return;
	}

	if (class_name) {
		zval **aggr_members,
			 **aggr_methods,
			 **aggr_props,
			 **method, **prop;

		class_name_lc = estrndup(class_name, class_name_len);
		zend_str_tolower(class_name_lc, class_name_len);

		if (zend_hash_find(Z_ARRVAL_P(aggr_info->aggr_members), class_name_lc,
						   class_name_len+1, (void **)&aggr_members) == FAILURE) {
			efree(class_name_lc);
			return;
		}

		zend_hash_find(Z_ARRVAL_PP(aggr_members), "methods", sizeof("methods"), (void**)&aggr_methods);
		for (zend_hash_internal_pointer_reset(Z_ARRVAL_PP(aggr_methods));
			 zend_hash_get_current_data(Z_ARRVAL_PP(aggr_methods), (void**)&method) == SUCCESS;
			 zend_hash_move_forward(Z_ARRVAL_PP(aggr_methods))) {
			zend_hash_del(&Z_OBJCE_P(obj)->function_table, Z_STRVAL_PP(method), Z_STRLEN_PP(method)+1);
		}

		zend_hash_find(Z_ARRVAL_PP(aggr_members), "properties", sizeof("properties"), (void**)&aggr_props);
		for (zend_hash_internal_pointer_reset(Z_ARRVAL_PP(aggr_props));
			 zend_hash_get_current_data(Z_ARRVAL_PP(aggr_props), (void**)&prop) == SUCCESS;
			 zend_hash_move_forward(Z_ARRVAL_PP(aggr_props))) {
			zend_hash_del(Z_OBJPROP_P(obj), Z_STRVAL_PP(prop), Z_STRLEN_PP(prop)+1);
		}

		zend_hash_del(Z_ARRVAL_P(aggr_info->aggr_members), class_name_lc, class_name_len+1);

		efree(class_name_lc);
	} else {
		zend_class_entry *orig_ce;
		zval **aggr_members;
		zval **aggr_props, **prop;

		if (zend_hash_find(EG(class_table), Z_OBJCE_P(obj)->name,
						   Z_OBJCE_P(obj)->name_length+1, (void **)&orig_ce) == FAILURE) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Internal deaggregation error");
			return;
		}

		for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(aggr_info->aggr_members));
			 zend_hash_get_current_data(Z_ARRVAL_P(aggr_info->aggr_members), (void **)&aggr_members) == SUCCESS;
			 zend_hash_move_forward(Z_ARRVAL_P(aggr_info->aggr_members))) {
			zend_hash_find(Z_ARRVAL_PP(aggr_members), "properties", sizeof("properties"), (void**)&aggr_props);
			for (zend_hash_internal_pointer_reset(Z_ARRVAL_PP(aggr_props));
				 zend_hash_get_current_data(Z_ARRVAL_PP(aggr_props), (void**)&prop) == SUCCESS;
				 zend_hash_move_forward(Z_ARRVAL_PP(aggr_props))) {
				zend_hash_del(Z_OBJPROP_P(obj), Z_STRVAL_PP(prop), Z_STRLEN_PP(prop)+1);
			}
		}

		/* OBJECT FIXME!! won't work with non-standard objects */
		(Z_OBJ_P(obj))->ce = orig_ce;
		zend_hash_index_del(BG(aggregation_table), (long)obj);
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\crc32.c"
/* {{{ proto string crc32(string str)
   Calculate the crc32 polynomial of a string */
PHP_NAMED_FUNCTION(php_if_crc32)
{
	unsigned int crc = ~0;
	char *p;
	int len, nr;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &p, &nr) == FAILURE) {
		return;
	}

	len = 0 ;
	for (len += nr; nr--; ++p) {
	    CRC32(crc, *p);
	}
	RETVAL_LONG(~crc);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\dir.c"
/* {{{ proto string readdir([resource dir_handle])
   Read directory entry from dir_handle */
PHP_NAMED_FUNCTION(php_if_readdir)
{
	pval **id, **tmp, *myself;
	php_stream *dirp;
	php_stream_dirent entry;

	FETCH_DIRP();

	if (php_stream_readdir(dirp, &entry)) {
		RETURN_STRINGL(entry.d_name, strlen(entry.d_name), 1);
	}
	RETURN_FALSE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto bool flock(resource fp, int operation [, int &wouldblock])
   Portable file locking */

static int flock_values[] = { LOCK_SH, LOCK_EX, LOCK_UN };

PHP_FUNCTION(flock)
{
	zval **arg1, **arg2, **arg3;
	int fd, act, arg_count = ZEND_NUM_ARGS();
	php_stream *stream;

	if (arg_count < 2 || arg_count > 3 || zend_get_parameters_ex(arg_count, &arg1, &arg2, &arg3) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	if (php_stream_cast(stream, PHP_STREAM_AS_FD, (void*)&fd, 1) == FAILURE)	{
		RETURN_FALSE;
	}

	convert_to_long_ex(arg2);

	act = Z_LVAL_PP(arg2) & 3;
	if (act < 1 || act > 3) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Illegal operation argument");
		RETURN_FALSE;
	}

	if (arg_count == 3) {
		convert_to_long_ex(arg3);
		Z_LVAL_PP(arg3) = 0;
	}

	/* flock_values contains all possible actions
	   if (arg2 & 4) we won't block on the lock */
	act = flock_values[act - 1] | (Z_LVAL_PP(arg2) & 4 ? LOCK_NB : 0);
	if (flock(fd, act)) {
		if (errno == EWOULDBLOCK && arg_count == 3) {
			Z_LVAL_PP(arg3) = 1;
		} else {
			RETURN_FALSE;
		}
	}
	RETURN_TRUE;
}

/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto resource tmpfile(void)
   Create a temporary file that will be deleted automatically after use */
PHP_NAMED_FUNCTION(php_if_tmpfile)
{
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 0) {
		WRONG_PARAM_COUNT;
	}

	stream = php_stream_fopen_tmpfile();

	if (stream)	{
		php_stream_to_zval(stream, return_value);
	}
	else	{
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto resource fopen(string filename, string mode [, bool use_include_path [, resource context]])
   Open a file or a URL and return a file pointer */
PHP_NAMED_FUNCTION(php_if_fopen)
{
	char *filename, *mode;
	int filename_len, mode_len;
	zend_bool use_include_path = 0;
	zval *zcontext = NULL;
	php_stream *stream;
	php_stream_context *context = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|br", &filename, &filename_len,
				&mode, &mode_len, &use_include_path, &zcontext) == FAILURE) {
		RETURN_FALSE;
	}
	if (zcontext) {
		ZEND_FETCH_RESOURCE(context, php_stream_context*, &zcontext, -1, "stream-context", le_stream_context);
	}

	stream = php_stream_open_wrapper_ex(filename, mode,
				(use_include_path ? USE_PATH : 0) | ENFORCE_SAFE_MODE | REPORT_ERRORS,
				NULL, context);

	if (stream == NULL)	{
		RETURN_FALSE;
	}

	php_stream_to_zval(stream, return_value);
	if (zcontext) {
		zend_list_addref(Z_RESVAL_P(zcontext));
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto bool fclose(resource fp)
   Close an open file pointer */
PHPAPI PHP_FUNCTION(fclose)
{
	zval **arg1;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);
	if (!stream->is_persistent) {
		zend_list_delete(stream->rsrc_id);
	} else {
		php_stream_pclose(stream);
	}

	RETURN_TRUE;
}

/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto bool feof(resource fp)
   Test for end-of-file on a file pointer */
PHPAPI PHP_FUNCTION(feof)
{
	zval **arg1;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	if (php_stream_eof(stream)) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto string fgets(resource fp[, int length])
   Get a line from file pointer */
PHPAPI PHP_FUNCTION(fgets)
{
	zval **arg1, **arg2;
	int len = 1024;
	char *buf = NULL;
	int argc = ZEND_NUM_ARGS();
	size_t line_len = 0;
	php_stream *stream;

	if (argc<1 || argc>2 || zend_get_parameters_ex(argc, &arg1, &arg2) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	if (argc == 1) {
		/* ask streams to give us a buffer of an appropriate size */
		buf = php_stream_get_line(stream, NULL, 0, &line_len);
		if (buf == NULL)
			goto exit_failed;
	} else if (argc > 1) {
		convert_to_long_ex(arg2);
		len = Z_LVAL_PP(arg2);

		if (len <= 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Length parameter must be greater than 0.");
			RETURN_FALSE;
		}

		buf = ecalloc(len + 1, sizeof(char));
		if (php_stream_get_line(stream, buf, len, &line_len) == NULL)
			goto exit_failed;
	}

	if (PG(magic_quotes_runtime)) {
		Z_STRVAL_P(return_value) = php_addslashes(buf, line_len, &Z_STRLEN_P(return_value), 1 TSRMLS_CC);
		Z_TYPE_P(return_value) = IS_STRING;
	} else {
		ZVAL_STRINGL(return_value, buf, line_len, 0);
		/* resize buffer if it's much larger than the result.
		 * Only needed if the user requested a buffer size. */
		if (argc > 1 && Z_STRLEN_P(return_value) < len / 2) {
			Z_STRVAL_P(return_value) = erealloc(buf, line_len + 1);
		}
	}
	return;

exit_failed:
	RETVAL_FALSE;
	if (buf)
		efree(buf);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto string fgetc(resource fp)
   Get a character from file pointer */
PHPAPI PHP_FUNCTION(fgetc)
{
	zval **arg1;
	char *buf;
	int result;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	buf = emalloc(2 * sizeof(char));

	result = php_stream_getc(stream);

	if (result == EOF) {
		efree(buf);
		RETVAL_FALSE;
	} else {
		buf[0] = result;
		buf[1] = '\0';

		RETURN_STRINGL(buf, 1, 0);
	}
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto string fgetss(resource fp, int length [, string allowable_tags])
   Get a line from file pointer and strip HTML tags */
PHPAPI PHP_FUNCTION(fgetss)
{
	zval **fd, **bytes, **allow=NULL;
	int len;
	size_t actual_len, retval_len;
	char *buf;
	php_stream *stream;
	char *allowed_tags=NULL;
	int allowed_tags_len=0;

	switch(ZEND_NUM_ARGS()) {
	case 2:
		if (zend_get_parameters_ex(2, &fd, &bytes) == FAILURE) {
			RETURN_FALSE;
		}
		break;
	case 3:
		if (zend_get_parameters_ex(3, &fd, &bytes, &allow) == FAILURE) {
			RETURN_FALSE;
		}
		convert_to_string_ex(allow);
		allowed_tags = Z_STRVAL_PP(allow);
		allowed_tags_len = Z_STRLEN_PP(allow);
		break;
	default:
		WRONG_PARAM_COUNT;
		/* NOTREACHED */
		break;
	}

	PHP_STREAM_TO_ZVAL(stream, fd);

	convert_to_long_ex(bytes);
	len = Z_LVAL_PP(bytes);
	if (len <= 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Length parameter must be greater than 0.");
		RETURN_FALSE;
	}

	buf = safe_emalloc(sizeof(char), (len + 1), 0);
	/*needed because recv doesnt set null char at end*/
	memset(buf, 0, len + 1);

	if (php_stream_get_line(stream, buf, len, &actual_len) == NULL)	{
		efree(buf);
		RETURN_FALSE;
	}

	/* strlen() can be used here since we are doing it on the return of an fgets() anyway */
	retval_len = php_strip_tags(buf, actual_len, &stream->fgetss_state, allowed_tags, allowed_tags_len);

	RETURN_STRINGL(buf, retval_len, 0);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int fwrite(resource fp, string str [, int length])
   Binary-safe file write */
PHPAPI PHP_FUNCTION(fwrite)
{
	zval **arg1, **arg2, **arg3=NULL;
	int ret;
	int num_bytes;
	char *buffer = NULL;
	php_stream *stream;

	switch (ZEND_NUM_ARGS()) {
	case 2:
		if (zend_get_parameters_ex(2, &arg1, &arg2)==FAILURE) {
			RETURN_FALSE;
		}
		convert_to_string_ex(arg2);
		num_bytes = Z_STRLEN_PP(arg2);
		break;
	case 3:
		if (zend_get_parameters_ex(3, &arg1, &arg2, &arg3)==FAILURE) {
			RETURN_FALSE;
		}
		convert_to_string_ex(arg2);
		convert_to_long_ex(arg3);
		num_bytes = MIN(Z_LVAL_PP(arg3), Z_STRLEN_PP(arg2));
		break;
	default:
		WRONG_PARAM_COUNT;
		/* NOTREACHED */
		break;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	if (!arg3 && PG(magic_quotes_runtime)) {
		buffer = estrndup(Z_STRVAL_PP(arg2), Z_STRLEN_PP(arg2));
		php_stripslashes(buffer, &num_bytes TSRMLS_CC);
	}

	ret = php_stream_write(stream, buffer ? buffer : Z_STRVAL_PP(arg2), num_bytes);
	if (buffer) {
		efree(buffer);
	}

	RETURN_LONG(ret);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto bool fflush(resource fp)
   Flushes output */
PHPAPI PHP_FUNCTION(fflush)
{
	zval **arg1;
	int ret;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	ret = php_stream_flush(stream);
	if (ret) {
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto bool rewind(resource fp)
   Rewind the position of a file pointer */
PHPAPI PHP_FUNCTION(rewind)
{
	zval **arg1;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	if (-1 == php_stream_rewind(stream)) {
		RETURN_FALSE;
	}
	RETURN_TRUE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int ftell(resource fp)
   Get file pointer's read/write position */
PHPAPI PHP_FUNCTION(ftell)
{
	zval **arg1;
	long ret;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	ret = php_stream_tell(stream);
	if (ret == -1)	{
		RETURN_FALSE;
	}
	RETURN_LONG(ret);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int fseek(resource fp, int offset [, int whence])
   Seek on a file pointer */
PHPAPI PHP_FUNCTION(fseek)
{
	zval **arg1, **arg2, **arg3;
	int argcount = ZEND_NUM_ARGS(), whence = SEEK_SET;
	php_stream *stream;

	if (argcount < 2 || argcount > 3 ||
		zend_get_parameters_ex(argcount, &arg1, &arg2, &arg3) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	convert_to_long_ex(arg2);
	if (argcount > 2) {
		convert_to_long_ex(arg3);
		whence = Z_LVAL_PP(arg3);
	}

	RETURN_LONG(php_stream_seek(stream, Z_LVAL_PP(arg2), whence));
}

/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int fpassthru(resource fp)
   Output all remaining data from a file pointer */

PHPAPI PHP_FUNCTION(fpassthru)
{
	zval **arg1;
	int size;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg1) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	size = php_stream_passthru(stream);
	RETURN_LONG(size);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int ftruncate(resource fp, int size)
   Truncate file to 'size' length */
PHP_NAMED_FUNCTION(php_if_ftruncate)
{
	zval **fp , **size;
	short int ret;
	int fd;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &fp, &size) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, fp);

	convert_to_long_ex(size);

	if (php_stream_is(stream, PHP_STREAM_IS_SOCKET))	{
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Can't truncate sockets!");
		RETURN_FALSE;
	}
	if (SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD, (void*)&fd, 1))	{
		ret = ftruncate(fd, Z_LVAL_PP(size));
		RETURN_LONG(ret + 1);
	}
	RETURN_FALSE;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto int fstat(resource fp)
   Stat() on a filehandle */
PHP_NAMED_FUNCTION(php_if_fstat)
{
	zval **fp;
	zval *stat_dev, *stat_ino, *stat_mode, *stat_nlink, *stat_uid, *stat_gid, *stat_rdev,
	 	*stat_size, *stat_atime, *stat_mtime, *stat_ctime, *stat_blksize, *stat_blocks;
	php_stream *stream;
	php_stream_statbuf stat_ssb;

	char *stat_sb_names[13]={"dev", "ino", "mode", "nlink", "uid", "gid", "rdev",
				  "size", "atime", "mtime", "ctime", "blksize", "blocks"};

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &fp) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, fp);

	if (php_stream_stat(stream, &stat_ssb)) {
		RETURN_FALSE;
	}

	array_init(return_value);

	MAKE_LONG_ZVAL_INCREF(stat_dev, stat_ssb.sb.st_dev);
	MAKE_LONG_ZVAL_INCREF(stat_ino, stat_ssb.sb.st_ino);
	MAKE_LONG_ZVAL_INCREF(stat_mode, stat_ssb.sb.st_mode);
	MAKE_LONG_ZVAL_INCREF(stat_nlink, stat_ssb.sb.st_nlink);
	MAKE_LONG_ZVAL_INCREF(stat_uid, stat_ssb.sb.st_uid);
	MAKE_LONG_ZVAL_INCREF(stat_gid, stat_ssb.sb.st_gid);
#ifdef HAVE_ST_RDEV
	MAKE_LONG_ZVAL_INCREF(stat_rdev, stat_ssb.sb.st_rdev);
#else
	MAKE_LONG_ZVAL_INCREF(stat_rdev, -1);
#endif
	MAKE_LONG_ZVAL_INCREF(stat_size, stat_ssb.sb.st_size);
#ifdef NETWARE
	MAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime.tv_sec);
	MAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime.tv_sec);
	MAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime.tv_sec);
#else
	MAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime);
	MAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime);
	MAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime);
#endif
#ifdef HAVE_ST_BLKSIZE
	MAKE_LONG_ZVAL_INCREF(stat_blksize, stat_ssb.sb.st_blksize);
#else
	MAKE_LONG_ZVAL_INCREF(stat_blksize,-1);
#endif
#ifdef HAVE_ST_BLOCKS
	MAKE_LONG_ZVAL_INCREF(stat_blocks, stat_ssb.sb.st_blocks);
#else
	MAKE_LONG_ZVAL_INCREF(stat_blocks,-1);
#endif
	/* Store numeric indexes in propper order */
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_dev, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ino, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mode, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_nlink, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_uid, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_gid, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_rdev, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_size, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_atime, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mtime, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ctime, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blksize, sizeof(zval *), NULL);
	zend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blocks, sizeof(zval *), NULL);

	/* Store string indexes referencing the same zval*/
	zend_hash_update(HASH_OF(return_value), stat_sb_names[0], strlen(stat_sb_names[0])+1, (void *)&stat_dev, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[1], strlen(stat_sb_names[1])+1, (void *)&stat_ino, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[2], strlen(stat_sb_names[2])+1, (void *)&stat_mode, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[3], strlen(stat_sb_names[3])+1, (void *)&stat_nlink, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[4], strlen(stat_sb_names[4])+1, (void *)&stat_uid, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[5], strlen(stat_sb_names[5])+1, (void *)&stat_gid, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[6], strlen(stat_sb_names[6])+1, (void *)&stat_rdev, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[7], strlen(stat_sb_names[7])+1, (void *)&stat_size, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[8], strlen(stat_sb_names[8])+1, (void *)&stat_atime, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[9], strlen(stat_sb_names[9])+1, (void *)&stat_mtime, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[10], strlen(stat_sb_names[10])+1, (void *)&stat_ctime, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[11], strlen(stat_sb_names[11])+1, (void *)&stat_blksize, sizeof(zval *), NULL);
	zend_hash_update(HASH_OF(return_value), stat_sb_names[12], strlen(stat_sb_names[12])+1, (void *)&stat_blocks, sizeof(zval *), NULL);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\file.c"
/* {{{ proto string fread(resource fp, int length)
   Binary-safe file read */
PHPAPI PHP_FUNCTION(fread)
{
	zval **arg1, **arg2;
	int len;
	php_stream *stream;

	if (ZEND_NUM_ARGS() != 2 || zend_get_parameters_ex(2, &arg1, &arg2) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	PHP_STREAM_TO_ZVAL(stream, arg1);

	convert_to_long_ex(arg2);
	len = Z_LVAL_PP(arg2);
	if (len <= 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Length parameter must be greater than 0.");
		RETURN_FALSE;
	}

	Z_STRVAL_P(return_value) = emalloc(len + 1);
	Z_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);

	/* needed because recv/read/gzread doesnt put a null at the end*/
	Z_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;

	if (PG(magic_quotes_runtime)) {
		Z_STRVAL_P(return_value) = php_addslashes(Z_STRVAL_P(return_value),
				Z_STRLEN_P(return_value), &Z_STRLEN_P(return_value), 1 TSRMLS_CC);
	}
	Z_TYPE_P(return_value) = IS_STRING;
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int fileperms(string filename)
   Get file permissions */
FileFunction(PHP_FN(fileperms), FS_PERMS)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int fileinode(string filename)
   Get file inode */
FileFunction(PHP_FN(fileinode), FS_INODE)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int filesize(string filename)
   Get file size */
FileFunction(PHP_FN(filesize), FS_SIZE)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int fileowner(string filename)
   Get file owner */
FileFunction(PHP_FN(fileowner), FS_OWNER)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int filegroup(string filename)
   Get file group */
FileFunction(PHP_FN(filegroup), FS_GROUP)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int fileatime(string filename)
   Get last access time of file */
FileFunction(PHP_FN(fileatime), FS_ATIME)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int filemtime(string filename)
   Get last modification time of file */
FileFunction(PHP_FN(filemtime), FS_MTIME)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto int filectime(string filename)
   Get inode modification time of file */
FileFunction(PHP_FN(filectime), FS_CTIME)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto string filetype(string filename)
   Get file type */
FileFunction(PHP_FN(filetype), FS_TYPE)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_writable(string filename)
   Returns true if file can be written */
FileFunction(PHP_FN(is_writable), FS_IS_W)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_readable(string filename)
   Returns true if file can be read */
FileFunction(PHP_FN(is_readable), FS_IS_R)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_executable(string filename)
   Returns true if file is executable */
FileFunction(PHP_FN(is_executable), FS_IS_X)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_file(string filename)
   Returns true if file is a regular file */
FileFunction(PHP_FN(is_file), FS_IS_FILE)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_dir(string filename)
   Returns true if file is directory */
FileFunction(PHP_FN(is_dir), FS_IS_DIR)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool is_link(string filename)
   Returns true if file is symbolic link */
FileFunction(PHP_FN(is_link), FS_IS_LINK)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto bool file_exists(string filename)
   Returns true if filename exists */
FileFunction(PHP_FN(file_exists), FS_EXISTS)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto array lstat(string filename)
   Give information about a file or symbolic link */
FileFunction(php_if_lstat, FS_LSTAT)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\filestat.c"
/* {{{ proto array stat(string filename)
   Give information about a file */
FileFunction(php_if_stat, FS_STAT)
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\md5.c"
/* {{{ proto string md5(string str)
   Calculate the md5 hash of a string */
PHP_NAMED_FUNCTION(php_if_md5)
{
	zval **arg;
	char md5str[33];
	PHP_MD5_CTX context;
	unsigned char digest[16];
	
	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg) == FAILURE) {
		WRONG_PARAM_COUNT;
	}
	convert_to_string_ex(arg);

	md5str[0] = '\0';
	PHP_MD5Init(&context);
	PHP_MD5Update(&context, Z_STRVAL_PP(arg), Z_STRLEN_PP(arg));
	PHP_MD5Final(digest, &context);
	make_digest(md5str, digest);
	RETVAL_STRING(md5str, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\md5.c"
/* {{{ proto string md5_file(string filename)
   Calculate the md5 hash of given filename */
PHP_NAMED_FUNCTION(php_if_md5_file)
{
	zval          **arg;
	char          md5str[33];
	unsigned char buf[1024];
	unsigned char digest[16];
	PHP_MD5_CTX   context;
	int           n;
	php_stream    *stream;

	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &arg) == FAILURE) {
		WRONG_PARAM_COUNT;
	}

	convert_to_string_ex(arg);

	stream = php_stream_open_wrapper(Z_STRVAL_PP(arg), "rb", REPORT_ERRORS | ENFORCE_SAFE_MODE, NULL);
	if (!stream) {
		RETURN_FALSE;
	}

	PHP_MD5Init(&context);

	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		PHP_MD5Update(&context, buf, n);
	}

	PHP_MD5Final(digest, &context);

	php_stream_close(stream);

	if (n<0) {
		RETURN_FALSE;
	}

	make_digest(md5str, digest);

	RETVAL_STRING(md5str, 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\reg.c"
/* {{{ proto string sql_regcase(string string)
   Make regular expression for case insensitive match */
PHPAPI PHP_FUNCTION(sql_regcase)
{
	zval **string;
	char *tmp;
	unsigned char c;
	register int i, j;
	
	if (ZEND_NUM_ARGS()!=1 || zend_get_parameters_ex(1, &string)==FAILURE) {
		WRONG_PARAM_COUNT;
	}	
	convert_to_string_ex(string);
	
	tmp = safe_emalloc(Z_STRLEN_PP(string), 4, 1);
	
	for (i = j = 0; i < Z_STRLEN_PP(string); i++) {
		c = (unsigned char) Z_STRVAL_PP(string)[i];
		if(isalpha(c)) {
			tmp[j++] = '[';
			tmp[j++] = toupper(c);
			tmp[j++] = tolower(c);
			tmp[j++] = ']';
		} else {
			tmp[j++] = c;
		}
	}
	tmp[j] = 0;

	RETVAL_STRINGL(tmp, j, 1);
	efree(tmp);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\string.c"
/* {{{ proto string join(array src, string glue)
   An alias for implode */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\standard\string.c"
/* {{{ proto string strchr(string haystack, string needle)
   An alias for strstr */
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\tokenizer\tokenizer.c"
/* {{{ proto array token_get_all(string source)
 */
PHP_FUNCTION(token_get_all)
{
	char *source = NULL;
	int argc = ZEND_NUM_ARGS();
	int source_len;
	zval source_z;
	zend_lex_state original_lex_state;

	if (zend_parse_parameters(argc TSRMLS_CC, "s", &source, &source_len) == FAILURE) 
		return;

	ZVAL_STRINGL(&source_z, source, source_len, 1);
	zend_save_lexical_state(&original_lex_state TSRMLS_CC);

	if (zend_prepare_string_for_scanning(&source_z, "" TSRMLS_CC) == FAILURE) {
		RETURN_EMPTY_STRING();
	}

	tokenize(return_value TSRMLS_CC);
	
	zend_restore_lexical_state(&original_lex_state TSRMLS_CC);
	zval_dtor(&source_z);
}
/* }}} */
#define ERROR_RegFunction_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\ext\tokenizer\tokenizer.c"
/* {{{ proto string token_name(int type)
 */
PHP_FUNCTION(token_name)
{
	int argc = ZEND_NUM_ARGS();
	long type;

	if (zend_parse_parameters(argc TSRMLS_CC, "l", &type) == FAILURE) {
		return;
	}
	RETVAL_STRING(get_token_type_name(type), 1);
}
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\sapi\apache\php_apache.c"
/* {{{ proto array getallheaders(void)
   Alias for apache_request_headers() */
/* }}} */
#define ERROR_RegCheck_Match_Error_in_FILE "D:\Backup - dev\NEW\SynWeb\PHP\..\!DOC\php-4.4.2\Zend\zend_builtin_functions.c"
/* {{{ proto int strlen(string str)
   Get string length */
ZEND_NAMED_FUNCTION(zend_if_strlen)
{
	zval **str;
	
	if (ZEND_NUM_ARGS() != 1 || zend_get_parameters_ex(1, &str) == FAILURE) {
		ZEND_WRONG_PARAM_COUNT();
	}
	convert_to_string_ex(str);
	RETVAL_LONG((*str)->value.str.len);
}
/* }}} */
